#define _CFFI_USE_EMBEDDING
#define _CFFI_

/* We try to define Py_LIMITED_API before including Python.h.

   Mess: we can only define it if Py_DEBUG, Py_TRACE_REFS and
   Py_REF_DEBUG are not defined.  This is a best-effort approximation:
   we can learn about Py_DEBUG from pyconfig.h, but it is unclear if
   the same works for the other two macros.  Py_DEBUG implies them,
   but not the other way around.
*/
#ifndef _CFFI_USE_EMBEDDING
#  include <pyconfig.h>
#  if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG)
#    define Py_LIMITED_API
#  endif
#endif

#include <Python.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>

/* This part is from file 'cffi/parse_c_type.h'.  It is copied at the
   beginning of C sources generated by CFFI's ffi.set_source(). */

typedef void *_cffi_opcode_t;

#define _CFFI_OP(opcode, arg)   (_cffi_opcode_t)(opcode | (((uintptr_t)(arg)) << 8))
#define _CFFI_GETOP(cffi_opcode)    ((unsigned char)(uintptr_t)cffi_opcode)
#define _CFFI_GETARG(cffi_opcode)   (((intptr_t)cffi_opcode) >> 8)

#define _CFFI_OP_PRIMITIVE       1
#define _CFFI_OP_POINTER         3
#define _CFFI_OP_ARRAY           5
#define _CFFI_OP_OPEN_ARRAY      7
#define _CFFI_OP_STRUCT_UNION    9
#define _CFFI_OP_ENUM           11
#define _CFFI_OP_FUNCTION       13
#define _CFFI_OP_FUNCTION_END   15
#define _CFFI_OP_NOOP           17
#define _CFFI_OP_BITFIELD       19
#define _CFFI_OP_TYPENAME       21
#define _CFFI_OP_CPYTHON_BLTN_V 23   // varargs
#define _CFFI_OP_CPYTHON_BLTN_N 25   // noargs
#define _CFFI_OP_CPYTHON_BLTN_O 27   // O  (i.e. a single arg)
#define _CFFI_OP_CONSTANT       29
#define _CFFI_OP_CONSTANT_INT   31
#define _CFFI_OP_GLOBAL_VAR     33
#define _CFFI_OP_DLOPEN_FUNC    35
#define _CFFI_OP_DLOPEN_CONST   37
#define _CFFI_OP_GLOBAL_VAR_F   39
#define _CFFI_OP_EXTERN_PYTHON  41

#define _CFFI_PRIM_VOID          0
#define _CFFI_PRIM_BOOL          1
#define _CFFI_PRIM_CHAR          2
#define _CFFI_PRIM_SCHAR         3
#define _CFFI_PRIM_UCHAR         4
#define _CFFI_PRIM_SHORT         5
#define _CFFI_PRIM_USHORT        6
#define _CFFI_PRIM_INT           7
#define _CFFI_PRIM_UINT          8
#define _CFFI_PRIM_LONG          9
#define _CFFI_PRIM_ULONG        10
#define _CFFI_PRIM_LONGLONG     11
#define _CFFI_PRIM_ULONGLONG    12
#define _CFFI_PRIM_FLOAT        13
#define _CFFI_PRIM_DOUBLE       14
#define _CFFI_PRIM_LONGDOUBLE   15

#define _CFFI_PRIM_WCHAR        16
#define _CFFI_PRIM_INT8         17
#define _CFFI_PRIM_UINT8        18
#define _CFFI_PRIM_INT16        19
#define _CFFI_PRIM_UINT16       20
#define _CFFI_PRIM_INT32        21
#define _CFFI_PRIM_UINT32       22
#define _CFFI_PRIM_INT64        23
#define _CFFI_PRIM_UINT64       24
#define _CFFI_PRIM_INTPTR       25
#define _CFFI_PRIM_UINTPTR      26
#define _CFFI_PRIM_PTRDIFF      27
#define _CFFI_PRIM_SIZE         28
#define _CFFI_PRIM_SSIZE        29
#define _CFFI_PRIM_INT_LEAST8   30
#define _CFFI_PRIM_UINT_LEAST8  31
#define _CFFI_PRIM_INT_LEAST16  32
#define _CFFI_PRIM_UINT_LEAST16 33
#define _CFFI_PRIM_INT_LEAST32  34
#define _CFFI_PRIM_UINT_LEAST32 35
#define _CFFI_PRIM_INT_LEAST64  36
#define _CFFI_PRIM_UINT_LEAST64 37
#define _CFFI_PRIM_INT_FAST8    38
#define _CFFI_PRIM_UINT_FAST8   39
#define _CFFI_PRIM_INT_FAST16   40
#define _CFFI_PRIM_UINT_FAST16  41
#define _CFFI_PRIM_INT_FAST32   42
#define _CFFI_PRIM_UINT_FAST32  43
#define _CFFI_PRIM_INT_FAST64   44
#define _CFFI_PRIM_UINT_FAST64  45
#define _CFFI_PRIM_INTMAX       46
#define _CFFI_PRIM_UINTMAX      47

#define _CFFI__NUM_PRIM         48
#define _CFFI__UNKNOWN_PRIM           (-1)
#define _CFFI__UNKNOWN_FLOAT_PRIM     (-2)
#define _CFFI__UNKNOWN_LONG_DOUBLE    (-3)

#define _CFFI__IO_FILE_STRUCT         (-1)


struct _cffi_global_s {
    const char *name;
    void *address;
    _cffi_opcode_t type_op;
    void *size_or_direct_fn;  // OP_GLOBAL_VAR: size, or 0 if unknown
                              // OP_CPYTHON_BLTN_*: addr of direct function
};

struct _cffi_getconst_s {
    unsigned long long value;
    const struct _cffi_type_context_s *ctx;
    int gindex;
};

struct _cffi_struct_union_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_STRUCT_UNION
    int flags;               // _CFFI_F_* flags below
    size_t size;
    int alignment;
    int first_field_index;   // -> _cffi_fields array
    int num_fields;
};
#define _CFFI_F_UNION         0x01   // is a union, not a struct
#define _CFFI_F_CHECK_FIELDS  0x02   // complain if fields are not in the
                                     // "standard layout" or if some are missing
#define _CFFI_F_PACKED        0x04   // for CHECK_FIELDS, assume a packed struct
#define _CFFI_F_EXTERNAL      0x08   // in some other ffi.include()
#define _CFFI_F_OPAQUE        0x10   // opaque

struct _cffi_field_s {
    const char *name;
    size_t field_offset;
    size_t field_size;
    _cffi_opcode_t field_type_op;
};

struct _cffi_enum_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_ENUM
    int type_prim;           // _CFFI_PRIM_xxx
    const char *enumerators; // comma-delimited string
};

struct _cffi_typename_s {
    const char *name;
    int type_index;   /* if opaque, points to a possibly artificial
                         OP_STRUCT which is itself opaque */
};

struct _cffi_type_context_s {
    _cffi_opcode_t *types;
    const struct _cffi_global_s *globals;
    const struct _cffi_field_s *fields;
    const struct _cffi_struct_union_s *struct_unions;
    const struct _cffi_enum_s *enums;
    const struct _cffi_typename_s *typenames;
    int num_globals;
    int num_struct_unions;
    int num_enums;
    int num_typenames;
    const char *const *includes;
    int num_types;
    int flags;      /* future extension */
};

struct _cffi_parse_info_s {
    const struct _cffi_type_context_s *ctx;
    _cffi_opcode_t *output;
    unsigned int output_size;
    size_t error_location;
    const char *error_message;
};

struct _cffi_externpy_s {
    const char *name;
    size_t size_of_result;
    void *reserved1, *reserved2;
};

#ifdef _CFFI_INTERNAL
static int parse_c_type(struct _cffi_parse_info_s *info, const char *input);
static int search_in_globals(const struct _cffi_type_context_s *ctx,
                             const char *search, size_t search_len);
static int search_in_struct_unions(const struct _cffi_type_context_s *ctx,
                                   const char *search, size_t search_len);
#endif

/* this block of #ifs should be kept exactly identical between
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
   and cffi/_cffi_include.h */
#if defined(_MSC_VER)
# include <malloc.h>   /* for alloca() */
# if _MSC_VER < 1600   /* MSVC < 2010 */
   typedef __int8 int8_t;
   typedef __int16 int16_t;
   typedef __int32 int32_t;
   typedef __int64 int64_t;
   typedef unsigned __int8 uint8_t;
   typedef unsigned __int16 uint16_t;
   typedef unsigned __int32 uint32_t;
   typedef unsigned __int64 uint64_t;
   typedef __int8 int_least8_t;
   typedef __int16 int_least16_t;
   typedef __int32 int_least32_t;
   typedef __int64 int_least64_t;
   typedef unsigned __int8 uint_least8_t;
   typedef unsigned __int16 uint_least16_t;
   typedef unsigned __int32 uint_least32_t;
   typedef unsigned __int64 uint_least64_t;
   typedef __int8 int_fast8_t;
   typedef __int16 int_fast16_t;
   typedef __int32 int_fast32_t;
   typedef __int64 int_fast64_t;
   typedef unsigned __int8 uint_fast8_t;
   typedef unsigned __int16 uint_fast16_t;
   typedef unsigned __int32 uint_fast32_t;
   typedef unsigned __int64 uint_fast64_t;
   typedef __int64 intmax_t;
   typedef unsigned __int64 uintmax_t;
# else
#  include <stdint.h>
# endif
# if _MSC_VER < 1800   /* MSVC < 2013 */
#  ifndef __cplusplus
    typedef unsigned char _Bool;
#  endif
# endif
#else
# include <stdint.h>
# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
#  include <alloca.h>
# endif
#endif

#ifdef __GNUC__
# define _CFFI_UNUSED_FN  __attribute__((unused))
#else
# define _CFFI_UNUSED_FN  /* nothing */
#endif

#ifdef __cplusplus
# ifndef _Bool
   typedef bool _Bool;   /* semi-hackish: C++ has no _Bool; bool is builtin */
# endif
#endif

/**********  CPython-specific section  **********/
#ifndef PYPY_VERSION


#if PY_MAJOR_VERSION >= 3
# define PyInt_FromLong PyLong_FromLong
#endif

#define _cffi_from_c_double PyFloat_FromDouble
#define _cffi_from_c_float PyFloat_FromDouble
#define _cffi_from_c_long PyInt_FromLong
#define _cffi_from_c_ulong PyLong_FromUnsignedLong
#define _cffi_from_c_longlong PyLong_FromLongLong
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong

#define _cffi_to_c_double PyFloat_AsDouble
#define _cffi_to_c_float PyFloat_AsDouble

#define _cffi_from_c_int(x, type)                                        \
    (((type)-1) > 0 ? /* unsigned */                                     \
        (sizeof(type) < sizeof(long) ?                                   \
            PyInt_FromLong((long)x) :                                    \
         sizeof(type) == sizeof(long) ?                                  \
            PyLong_FromUnsignedLong((unsigned long)x) :                  \
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \
        (sizeof(type) <= sizeof(long) ?                                  \
            PyInt_FromLong((long)x) :                                    \
            PyLong_FromLongLong((long long)x)))

#define _cffi_to_c_int(o, type)                                          \
    ((type)(                                                             \
     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \
                                         : (type)_cffi_to_c_i8(o)) :     \
     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \
                                         : (type)_cffi_to_c_i16(o)) :    \
     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \
                                         : (type)_cffi_to_c_i32(o)) :    \
     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \
                                         : (type)_cffi_to_c_i64(o)) :    \
     (Py_FatalError("unsupported size for type " #type), (type)0)))

#define _cffi_to_c_i8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[1])
#define _cffi_to_c_u8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[2])
#define _cffi_to_c_i16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[3])
#define _cffi_to_c_u16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[4])
#define _cffi_to_c_i32                                                   \
                 ((int(*)(PyObject *))_cffi_exports[5])
#define _cffi_to_c_u32                                                   \
                 ((unsigned int(*)(PyObject *))_cffi_exports[6])
#define _cffi_to_c_i64                                                   \
                 ((long long(*)(PyObject *))_cffi_exports[7])
#define _cffi_to_c_u64                                                   \
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])
#define _cffi_to_c_char                                                  \
                 ((int(*)(PyObject *))_cffi_exports[9])
#define _cffi_from_c_pointer                                             \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[10])
#define _cffi_to_c_pointer                                               \
    ((char *(*)(PyObject *, struct _cffi_ctypedescr *))_cffi_exports[11])
#define _cffi_get_struct_layout                                          \
    not used any more
#define _cffi_restore_errno                                              \
    ((void(*)(void))_cffi_exports[13])
#define _cffi_save_errno                                                 \
    ((void(*)(void))_cffi_exports[14])
#define _cffi_from_c_char                                                \
    ((PyObject *(*)(char))_cffi_exports[15])
#define _cffi_from_c_deref                                               \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[16])
#define _cffi_to_c                                                       \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[17])
#define _cffi_from_c_struct                                              \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[18])
#define _cffi_to_c_wchar_t                                               \
    ((wchar_t(*)(PyObject *))_cffi_exports[19])
#define _cffi_from_c_wchar_t                                             \
    ((PyObject *(*)(wchar_t))_cffi_exports[20])
#define _cffi_to_c_long_double                                           \
    ((long double(*)(PyObject *))_cffi_exports[21])
#define _cffi_to_c__Bool                                                 \
    ((_Bool(*)(PyObject *))_cffi_exports[22])
#define _cffi_prepare_pointer_call_argument                              \
    ((Py_ssize_t(*)(struct _cffi_ctypedescr *,                           \
                    PyObject *, char **))_cffi_exports[23])
#define _cffi_convert_array_from_object                                  \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[24])
#define _CFFI_CPIDX  25
#define _cffi_call_python                                                \
    ((void(*)(struct _cffi_externpy_s *, char *))_cffi_exports[_CFFI_CPIDX])
#define _CFFI_NUM_EXPORTS 26

struct _cffi_ctypedescr;

static void *_cffi_exports[_CFFI_NUM_EXPORTS];

#define _cffi_type(index)   (                           \
    assert((((uintptr_t)_cffi_types[index]) & 1) == 0), \
    (struct _cffi_ctypedescr *)_cffi_types[index])

static PyObject *_cffi_init(const char *module_name, Py_ssize_t version,
                            const struct _cffi_type_context_s *ctx)
{
    PyObject *module, *o_arg, *new_module;
    void *raw[] = {
        (void *)module_name,
        (void *)version,
        (void *)_cffi_exports,
        (void *)ctx,
    };

    module = PyImport_ImportModule("_cffi_backend");
    if (module == NULL)
        goto failure;

    o_arg = PyLong_FromVoidPtr((void *)raw);
    if (o_arg == NULL)
        goto failure;

    new_module = PyObject_CallMethod(
        module, (char *)"_init_cffi_1_0_external_module", (char *)"O", o_arg);

    Py_DECREF(o_arg);
    Py_DECREF(module);
    return new_module;

  failure:
    Py_XDECREF(module);
    return NULL;
}

/**********  end CPython-specific section  **********/
#else
_CFFI_UNUSED_FN
static void (*_cffi_call_python_org)(struct _cffi_externpy_s *, char *);
# define _cffi_call_python  _cffi_call_python_org
#endif


#define _cffi_array_len(array)   (sizeof(array) / sizeof((array)[0]))

#define _cffi_prim_int(size, sign)                                      \
    ((size) == 1 ? ((sign) ? _CFFI_PRIM_INT8  : _CFFI_PRIM_UINT8)  :    \
     (size) == 2 ? ((sign) ? _CFFI_PRIM_INT16 : _CFFI_PRIM_UINT16) :    \
     (size) == 4 ? ((sign) ? _CFFI_PRIM_INT32 : _CFFI_PRIM_UINT32) :    \
     (size) == 8 ? ((sign) ? _CFFI_PRIM_INT64 : _CFFI_PRIM_UINT64) :    \
     _CFFI__UNKNOWN_PRIM)

#define _cffi_prim_float(size)                                          \
    ((size) == sizeof(float) ? _CFFI_PRIM_FLOAT :                       \
     (size) == sizeof(double) ? _CFFI_PRIM_DOUBLE :                     \
     (size) == sizeof(long double) ? _CFFI__UNKNOWN_LONG_DOUBLE :       \
     _CFFI__UNKNOWN_FLOAT_PRIM)

#define _cffi_check_int(got, got_nonpos, expected)      \
    ((got_nonpos) == (expected <= 0) &&                 \
     (got) == (unsigned long long)expected)

#ifdef MS_WIN32
# define _cffi_stdcall  __stdcall
#else
# define _cffi_stdcall  /* nothing */
#endif

#ifdef __cplusplus
}
#endif

#define _CFFI_MODULE_NAME  "pythonscriptcffi"
#define _CFFI_PYTHON_STARTUP_CODE  "print('============> INIT CFFI <===========')\n" \
"\n" \
"from pythonscriptcffi import ffi, lib\n" \
"\n" \
"# Protect python objects passed to C from beeing garbage collected\n" \
"class ProtectFromGC:\n" \
"    def __init__(self):\n" \
"        self._data = {}\n" \
"\n" \
"    def register(self, value):\n" \
"        self._data[id(value)] = value\n" \
"\n" \
"    def unregister(self, value):\n" \
"        del self._data[id(value)]\n" \
"\n" \
"    def unregister_by_id(self, id):\n" \
"        del self._data[id]\n" \
"protect_from_gc = ProtectFromGC()\n" \
"\n" \
"\n" \
"def connect_handle(obj):\n" \
"    handle = obj.__dict__.get('_cffi_handle')\n" \
"    if handle:\n" \
"        return handle\n" \
"    else:\n" \
"        handle = ffi.new_handle(obj)\n" \
"        obj._cffi_handle = handle\n" \
"        return handle\n" \
"\n" \
"\n" \
"@ffi.def_extern()\n" \
"def pybind_load_exposed_class_per_module(modname):\n" \
"    modname = ffi.string(modname)\n" \
"    __import__(modname)  # Force lazy loading of the module\n" \
"    cls = get_exposed_class_per_module(modname)\n" \
"    return connect_handle(cls)\n" \
"\n" \
"\n" \
"@ffi.def_extern()\n" \
"def pybind_wrap_gdobj_with_class(cls_handle, gdobj):\n" \
"    instance = ffi.from_handle(cls_handle)(gdobj)\n" \
"    protect_from_gc.register(instance)\n" \
"    return connect_handle(instance)\n" \
"\n" \
"\n" \
"@ffi.def_extern()\n" \
"def pybind_instanciate_from_classname(classname):\n" \
"    cls = get_exposed_class_per_name(ffi.string(classname))\n" \
"    instance = cls()\n" \
"    protect_from_gc.register(instance)\n" \
"    return connect_handle(instance)\n" \
"\n" \
"\n" \
"@ffi.def_extern()\n" \
"def pybind_release_instance(handle):\n" \
"    instance = ffi.from_handle(handle)\n" \
"    protect_from_gc.unregister(instance)\n" \
"\n" \
"\n" \
"@ffi.def_extern()\n" \
"def pybind_call_meth(handle, methname, args, argcount, ret, error):\n" \
"    instance = ffi.from_handle(handle)\n" \
"    meth = getattr(instance, ffi.string(methname))\n" \
"    print('Calling %s on %s (%s) ==> %s' % (ffi.string(methname), handle, instance, meth))\n" \
"    pyargs = [variant_to_pyobj(args[i]) for i in range(argcount)]\n" \
"    try:\n" \
"        pyret = meth(*pyargs)\n" \
"        pyobj_to_variant(pyret, ret)\n" \
"    except NotImplementedError:\n" \
"        error[0] = 1\n" \
"    except TypeError:\n" \
"        error[0] = 2\n" \
"    # TODO: handle errors here\n" \
"\n" \
"# =====\n" \
"\n" \
"@ffi.def_extern()\n" \
"def do_stuff(x, y):\n" \
"    return x + y\n" \
"\n" \
"@ffi.def_extern()\n" \
"def py_instance_set_godot_obj(instance_handle, godot_obj):\n" \
"    self = ffi.from_handle(ffi.cast('void*', instance_handle))\n" \
"    print('** %s switched from %s to %s' % (self, self._gd_obj, godot_obj))\n" \
"    self._gd_obj = godot_obj\n" \
"\n" \
"\n" \
"# TODO: find a cleaner way to prevent the newly initialized binding from beeing\n" \
"# garbage collected as soon as we leave the function\n" \
"newly_intanciated_anchor = []\n" \
"@ffi.def_extern()\n" \
"def instanciate_binding_from_godot_obj(py_cls_handle, godot_obj):\n" \
"    global newly_intanciated_anchor\n" \
"    py_cls = ffi.from_handle(ffi.cast('void*', py_cls_handle))\n" \
"    instance = py_cls(godot_obj)\n" \
"    instance_handle = ffi.new_handle(instance)\n" \
"    newly_intanciated_anchor.append((instance, instance_handle))\n" \
"    return instance_handle\n" \
"\n" \
"\n" \
"@ffi.def_extern()\n" \
"def variant_to_pyobj2(v):\n" \
"    global newly_intanciated_anchor\n" \
"    instance = variant_to_pyobj(v)\n" \
"    instance_handle = ffi.new_handle(instance)\n" \
"    newly_intanciated_anchor.append((instance, instance_handle))\n" \
"    return instance_handle\n" \
"\n" \
"\n" \
"@ffi.def_extern()\n" \
"def pyobj_to_variant2(v):\n" \
"    global newly_intanciated_anchor\n" \
"    instance = pyobj_to_variant(v)\n" \
"    instance_handle = ffi.new_handle(instance)\n" \
"    newly_intanciated_anchor.append((instance, instance_handle))\n" \
"    return instance_handle\n" \
"\n" \
"\n" \
"@ffi.def_extern()\n" \
"def variants_to_pyobjs(args, argcount):\n" \
"    return [variant_to_pyobj(args[i]) for i in range(argcount)]\n" \
"\n" \
"\n" \
"@ffi.def_extern()\n" \
"def call_with_variants(func, args, argcount):\n" \
"    pyfunc = ffi.from_handle(ffi.cast('void*', func))\n" \
"    pyargs = [variant_to_pyobj(args[i]) for i in range(argcount)]\n" \
"    pyret = pyfunc(*pyargs)\n" \
"    return pyobj_to_variant(pyret)\n" \
"\n" \
"from pythonscriptcffi import ffi, lib\n" \
"\n" \
"\n" \
"def godot_array_to_pyobj(p_gdarray):\n" \
"    return [variant_to_pyobj(lib.godot_array_get(p_gdarray, i))\n" \
"            for i in range(lib.godot_array_size(p_gdarray))]\n" \
"\n" \
"\n" \
"def godot_dictionary_to_pyobj(p_gddict):\n" \
"    pydict = {}\n" \
"    gdkeys = lib.godot_dictionary_keys(p_gddict)\n" \
"    p_gdkeys = ffi.new(\"godot_array*\", gdkeys)\n" \
"    for i in range(lib.godot_array_size(p_gdkeys)):\n" \
"        p_key = lib.godot_array_get(p_gdkeys, i)\n" \
"        keystr = lib.godot_variant_as_string(p_key)\n" \
"        p_keystr = ffi.new(\"godot_string*\", keystr)\n" \
"        c_str = lib.godot_string_c_str(p_keystr)\n" \
"        value = lib.godot_dictionary_operator_index(p_gddict, p_key)\n" \
"        # Recursive conversion of dict values\n" \
"        pydict[ffi.string(c_str)] = variant_to_pyobj(value)\n" \
"    return pydict\n" \
"\n" \
"\n" \
"def godot_string_to_pyobj(gdstring):\n" \
"    p_gdstring = ffi.new(\"godot_string*\", gdstring)\n" \
"    c_str = lib.godot_string_c_str(p_gdstring)\n" \
"    return ffi.string(c_str)\n" \
"\n" \
"\n" \
"def variant_to_pyobj(p_gdvar):\n" \
"    \"\"\"\n" \
"    Convert Godot variant to regular Python object\n" \
"    :param p_gdvar: Godot variant as ``<cdata 'struct godot_variant *'>`` (note the pointer)\n" \
"    \"\"\"\n" \
"    gdtype = lib.godot_variant_get_type(p_gdvar)\n" \
"    if gdtype == lib.GODOT_VARIANT_TYPE_NIL:\n" \
"        return None\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_BOOL:\n" \
"        return bool(lib.godot_variant_as_bool(p_gdvar))\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_INT:\n" \
"        return int(lib.godot_variant_as_int(p_gdvar))\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_REAL:\n" \
"        return float(lib.godot_variant_as_real(p_gdvar))\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_STRING:\n" \
"        return godot_string_to_pyobj(lib.godot_variant_as_string(p_gdvar))\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_VECTOR2:\n" \
"        raise TypeError(\"Variant type `Vector2` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_RECT2:\n" \
"        raise TypeError(\"Variant type `Rect2` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_VECTOR3:\n" \
"        raise TypeError(\"Variant type `Vector3` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_TRANSFORM2D:\n" \
"        raise TypeError(\"Variant type `Transform2d` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_PLANE:\n" \
"        raise TypeError(\"Variant type `Plane` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_QUAT:\n" \
"        raise TypeError(\"Variant type `Quat` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_RECT3:\n" \
"        raise TypeError(\"Variant type `Rect3` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_BASIS:\n" \
"        raise TypeError(\"Variant type `Basis` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_TRANSFORM:\n" \
"        raise TypeError(\"Variant type `Transform` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_COLOR:\n" \
"        raise TypeError(\"Variant type `Color` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_IMAGE:\n" \
"        raise TypeError(\"Variant type `Image` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_NODE_PATH:\n" \
"        raise TypeError(\"Variant type `NodePath` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_RID:\n" \
"        raise TypeError(\"Variant type `Rid` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_OBJECT:\n" \
"        raise TypeError(\"Variant type `Object` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_INPUT_EVENT:\n" \
"        raise TypeError(\"Variant type `InputEvent` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_DICTIONARY:\n" \
"        gddict = lib.godot_variant_as_dictionary(p_gdvar)\n" \
"        return godot_dictionary_to_pyobj(ffi.addressof(gddict))\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_ARRAY:\n" \
"        gdarray = lib.godot_variant_as_array(p_gdvar)\n" \
"        return godot_array_to_pyobj(ffi.addressof(gdarray))\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolByteArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_INT_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolIntArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_REAL_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolRealArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_STRING_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolStringArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolVector2Array` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolVector3Array` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolColorArray` not implemented yet\")\n" \
"    else:\n" \
"        raise TypeError(\"Unknown Variant type `%s` (this should never happen !)\" % gdtype)\n" \
"\n" \
"\n" \
"def new_raw(gdtype):\n" \
"    if gdtype == lib.GODOT_VARIANT_TYPE_NIL:\n" \
"        return ffi.NULL\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_BOOL:\n" \
"        return ffi.new('godot_bool*')\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_INT:\n" \
"        return ffi.new('godot_int*')\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_REAL:\n" \
"        return ffi.new('godot_real*')\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_STRING:\n" \
"        return ffi.new('godot_string*')\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_VECTOR2:\n" \
"        raise TypeError(\"Type conversion `Vector2` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_RECT2:\n" \
"        raise TypeError(\"Type conversion `Rect2` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_VECTOR3:\n" \
"        raise TypeError(\"Type conversion `Vector3` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_TRANSFORM2D:\n" \
"        raise TypeError(\"Type conversion `Transform2d` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_PLANE:\n" \
"        raise TypeError(\"Type conversion `Plane` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_QUAT:\n" \
"        raise TypeError(\"Type conversion `Quat` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_RECT3:\n" \
"        raise TypeError(\"Type conversion `Rect3` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_BASIS:\n" \
"        raise TypeError(\"Type conversion `Basis` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_TRANSFORM:\n" \
"        raise TypeError(\"Type conversion `Transform` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_COLOR:\n" \
"        raise TypeError(\"Type conversion `Color` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_IMAGE:\n" \
"        raise TypeError(\"Type conversion `Image` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_NODE_PATH:\n" \
"        raise TypeError(\"Type conversion `NodePath` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_RID:\n" \
"        raise TypeError(\"Type conversion `Rid` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_OBJECT:\n" \
"        return ffi.new('godot_object**')\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_INPUT_EVENT:\n" \
"        raise TypeError(\"Type conversion `InputEvent` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_DICTIONARY:\n" \
"        return godot_dictionary_to_pyobj(p_raw)\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_ARRAY:\n" \
"        return godot_array_to_pyobj(p_raw)\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolByteArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_INT_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolIntArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_REAL_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolRealArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_STRING_ARRAY:\n" \
"        return ffi.new('godot_pool_string_array*')\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolVector2Array` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolVector3Array` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolColorArray` not implemented yet\")\n" \
"    else:\n" \
"        raise TypeError(\"Unknown Variant type `%s` (this should never happen !)\" % gdtype)\n" \
"\n" \
"\n" \
"def raw_to_pyobj(gdtype, p_raw, hint_string=None):\n" \
"    if gdtype == lib.GODOT_VARIANT_TYPE_NIL:\n" \
"        return None\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_BOOL:\n" \
"        return bool(p_raw[0])\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_INT:\n" \
"        return int(p_raw[0])\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_REAL:\n" \
"        return float(p_raw[0])\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_STRING:\n" \
"        return godot_string_to_pyobj(p_raw[0])\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_VECTOR2:\n" \
"        raise TypeError(\"Type conversion `Vector2` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_RECT2:\n" \
"        raise TypeError(\"Type conversion `Rect2` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_VECTOR3:\n" \
"        raise TypeError(\"Type conversion `Vector3` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_TRANSFORM2D:\n" \
"        raise TypeError(\"Type conversion `Transform2d` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_PLANE:\n" \
"        raise TypeError(\"Type conversion `Plane` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_QUAT:\n" \
"        raise TypeError(\"Type conversion `Quat` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_RECT3:\n" \
"        raise TypeError(\"Type conversion `Rect3` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_BASIS:\n" \
"        raise TypeError(\"Type conversion `Basis` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_TRANSFORM:\n" \
"        raise TypeError(\"Type conversion `Transform` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_COLOR:\n" \
"        raise TypeError(\"Type conversion `Color` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_IMAGE:\n" \
"        raise TypeError(\"Type conversion `Image` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_NODE_PATH:\n" \
"        raise TypeError(\"Type conversion `NodePath` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_RID:\n" \
"        raise TypeError(\"Type conversion `Rid` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_OBJECT:\n" \
"        return getattr(module, hint_string)(p_raw[0])\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_INPUT_EVENT:\n" \
"        raise TypeError(\"Type conversion `InputEvent` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_DICTIONARY:\n" \
"        return godot_dictionary_to_pyobj(p_raw)\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_ARRAY:\n" \
"        return godot_array_to_pyobj(p_raw)\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolByteArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_INT_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolIntArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_REAL_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolRealArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_STRING_ARRAY:\n" \
"        ret = []\n" \
"        for i in range(lib.godot_pool_string_array_size(p_raw)):\n" \
"            ret.append(godot_string_to_pyobj(lib.godot_pool_string_array_get(p_raw, i)))\n" \
"        return ret\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolVector2Array` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolVector3Array` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolColorArray` not implemented yet\")\n" \
"    else:\n" \
"        raise TypeError(\"Unknown Variant type `%s` (this should never happen !)\" % gdtype)\n" \
"\n" \
"\n" \
"def pyobj_to_variant(pyobj, gdvar=None):\n" \
"    gdvar = gdvar if gdvar else ffi.new('godot_variant*')\n" \
"    if pyobj is None:\n" \
"        return\n" \
"    elif (isinstance(pyobj, bool)):\n" \
"        lib.godot_variant_new_bool(gdvar, pyobj)\n" \
"    elif (isinstance(pyobj, int)):\n" \
"        lib.godot_variant_new_int(gdvar, pyobj)\n" \
"    elif (isinstance(pyobj, float)):\n" \
"        lib.godot_variant_new_real(gdvar, pyobj)\n" \
"    elif (isinstance(pyobj, str)):\n" \
"        gdstr = ffi.new(\"godot_string*\")\n" \
"        pyobj_as_bytes = pyobj.encode()\n" \
"        lib.godot_string_new_data(gdstr, pyobj_as_bytes, len(pyobj_as_bytes))\n" \
"        lib.godot_variant_new_string(gdvar, gdstr)\n" \
"    elif (isinstance(pyobj, bytes)):\n" \
"        gdstr = ffi.new(\"godot_string*\")\n" \
"        lib.godot_string_new_data(gdstr, pyobj, len(pyobj))\n" \
"        lib.godot_variant_new_string(gdvar, gdstr)\n" \
"    elif hasattr(pyobj, \"_gd_obj\"):\n" \
"        lib.godot_variant_new_object(gdvar, pyobj._gd_obj)\n" \
"    else:\n" \
"        raise TypeError(\"Cannot convert `%s` to Godot's Variant\" % pyobj)\n" \
"    return gdvar\n" \
"\n" \
"\n" \
"def pyobj_to_raw(gdtype, pyobj):\n" \
"    if gdtype == lib.GODOT_VARIANT_TYPE_NIL:\n" \
"        if pyobj is not None:\n" \
"            raise TypeError(\"`%s` should be of type None\" % pyobj)\n" \
"        return ffi.NULL\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_BOOL:\n" \
"        if not isinstance(pyobj, bool):\n" \
"            raise TypeError(\"`%s` should be of type bool\" % pyobj)\n" \
"        return ffi.new(\"godot_bool*\", 1 if pyobj else 0)\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_INT:\n" \
"        if not isinstance(pyobj, int):\n" \
"            raise TypeError(\"`%s` should be of type int\" % pyobj)\n" \
"        return ffi.new(\"godot_int*\", pyobj)\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_REAL:\n" \
"        if not isinstance(pyobj, float):\n" \
"            raise TypeError(\"`%s` should be of type float\" % pyobj)\n" \
"        return ffi.new(\"godot_real*\", pyobj)\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_STRING:\n" \
"        if not isinstance(pyobj, str):\n" \
"            raise TypeError(\"`%s` should be of type str\" % pyobj)\n" \
"        return ffi.new(\"wchar_t*\", pyobj)\n" \
"        # return ffi.new(\"char*\", pyobj)\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_VECTOR2:\n" \
"        raise TypeError(\"Variant type `Vector2` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_RECT2:\n" \
"        raise TypeError(\"Variant type `Rect2` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_VECTOR3:\n" \
"        raise TypeError(\"Variant type `Vector3` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_TRANSFORM2D:\n" \
"        raise TypeError(\"Variant type `Transform2d` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_PLANE:\n" \
"        raise TypeError(\"Variant type `Plane` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_QUAT:\n" \
"        raise TypeError(\"Variant type `Quat` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_RECT3:\n" \
"        raise TypeError(\"Variant type `Rect3` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_BASIS:\n" \
"        raise TypeError(\"Variant type `Basis` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_TRANSFORM:\n" \
"        raise TypeError(\"Variant type `Transform` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_COLOR:\n" \
"        raise TypeError(\"Variant type `Color` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_IMAGE:\n" \
"        raise TypeError(\"Variant type `Image` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_NODE_PATH:\n" \
"        raise TypeError(\"Variant type `NodePath` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_RID:\n" \
"        raise TypeError(\"Variant type `Rid` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_OBJECT:\n" \
"        raise TypeError(\"Variant type `Object` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_INPUT_EVENT:\n" \
"        raise TypeError(\"Variant type `InputEvent` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_DICTIONARY:\n" \
"        if not isinstance(pyobj, dict):\n" \
"            raise TypeError(\"`%s` should be of type dict\" % pyobj)\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_ARRAY:\n" \
"        if not isinstance(pyobj, list):\n" \
"            raise TypeError(\"`%s` should be of type list\" % pyobj)\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolByteArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_INT_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolIntArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_REAL_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolRealArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_STRING_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolStringArray` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolVector2Array` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolVector3Array` not implemented yet\")\n" \
"    elif gdtype == lib.GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY:\n" \
"        raise TypeError(\"Variant type `PoolColorArray` not implemented yet\")\n" \
"    else:\n" \
"        raise TypeError(\"Unknown Variant type `%s` (this should never happen !)\" % gdtype)\n" \
"import imp\n" \
"import sys\n" \
"\n" \
"\n" \
"__exposed_classes = {}\n" \
"__exposed_classes_per_module = {}\n" \
"\n" \
"\n" \
"class ExportedField:\n" \
"    def __init__(self, type, default):\n" \
"        self.type = type\n" \
"        self.default = default\n" \
"\n" \
"\n" \
"def exposed(cls=None, tool=False):\n" \
"\n" \
"    def wrapper(cls):\n" \
"        global __exposed_classes, __exposed_classes_per_module\n" \
"        print(\"Exposing %s.%s Python class to Godot.\" % (cls.__module__, cls))\n" \
"        assert cls.__name__ not in __exposed_classes\n" \
"        assert cls.__module__ not in __exposed_classes_per_module\n" \
"        cls._tool = tool\n" \
"        __exposed_classes[cls.__name__] = cls\n" \
"        __exposed_classes_per_module[cls.__module__] = cls\n" \
"        return cls\n" \
"\n" \
"    if cls:\n" \
"        return wrapper(cls)\n" \
"    else:\n" \
"        return wrapper\n" \
"\n" \
"\n" \
"def export(type, default=None):\n" \
"    return ExportedField(type, default)\n" \
"\n" \
"\n" \
"def get_exposed_class_per_module(module):\n" \
"    if not isinstance(module, str):\n" \
"        module = module.__name__\n" \
"    print('RESOLVED', module, __exposed_classes_per_module[module])\n" \
"    return __exposed_classes_per_module[module]\n" \
"\n" \
"\n" \
"def get_exposed_class_per_name(classname):\n" \
"    return __exposed_classes[classname]\n" \
"\n" \
"\n" \
"module = imp.new_module(\"godot\")\n" \
"module.export = export\n" \
"module.exposed = exposed\n" \
"module.get_exposed_class_per_module = get_exposed_class_per_module\n" \
"module.get_exposed_class_per_name = get_exposed_class_per_name\n" \
"\n" \
"sys.modules[\"godot\"] = module\n" \
"import sys\n" \
"from types import ModuleType\n" \
"from pythonscriptcffi import ffi, lib\n" \
"from functools import partial\n" \
"\n" \
"\n" \
"class GlobalConstants:\n" \
"    _instance = lib.godot_global_get_singleton(b\"GlobalConstants\")\n" \
"    _meth_get_global_constant_count = lib.godot_method_bind_get_method(b\"_GlobalConstants\", b\"get_global_constant_count\")\n" \
"    _meth_get_global_constant_name = lib.godot_method_bind_get_method(b\"_GlobalConstants\", b\"get_global_constant_name\")\n" \
"    _meth_get_global_constant_value = lib.godot_method_bind_get_method(b\"_GlobalConstants\", b\"get_global_constant_value\")\n" \
"\n" \
"\n" \
"    @classmethod\n" \
"    def get_global_constansts(cls):\n" \
"        import pdb; pdb.set_trace()\n" \
"        constants = {}\n" \
"        for i in range(lib.godot_get_global_constant_count()):\n" \
"            key = ffi.string(lib.godot_get_global_constant_name(i)).decode()\n" \
"            value = lib.godot_get_global_constant_value(i)\n" \
"            constants[key] = value\n" \
"        return constants\n" \
"\n" \
"    # ClassDB doesn't provide access for GlobalContansts yet\n" \
"    # @classmethod\n" \
"    # def get_global_constansts(cls):\n" \
"    #     constants = {}\n" \
"    #     ret = ffi.new(\"godot_int*\")\n" \
"    #     import pdb; pdb.set_trace()\n" \
"    #     lib.godot_method_bind_ptrcall(cls._meth_get_global_constant_count, cls._instance, ffi.NULL, ret)\n" \
"    #     for i in range(int(ret)):\n" \
"    #         arg = ffi.new(\"godot_int*\", i)\n" \
"    #         args = ffi.new(\"void*[1]\", [arg])\n" \
"    #         # Retrieve key\n" \
"    #         ret = ffi.new(\"godot_string*\")\n" \
"    #         lib.godot_method_bind_ptrcall(cls._meth_get_global_constant_name, cls._instance, args, ret)\n" \
"    #         key = ffi.string(ret)\n" \
"    #         # Retrieve value\n" \
"    #         ret = ffi.new(\"godot_int*\")\n" \
"    #         lib.godot_method_bind_ptrcall(cls._meth_get_global_constant_value, cls._instance, args, ret)\n" \
"    #         value = int(ret)\n" \
"    #         constants[key] = value\n" \
"    #     return constants\n" \
"\n" \
"\n" \
"class ClassDB:\n" \
"    _instance = lib.godot_global_get_singleton(b\"ClassDB\")\n" \
"    _meth_instance = lib.godot_method_bind_get_method(b\"_ClassDB\", b\"instance\")\n" \
"    _meth_get_class_list = lib.godot_method_bind_get_method(b\"_ClassDB\", b\"get_class_list\")\n" \
"    _meth_get_method_list = lib.godot_method_bind_get_method(b\"_ClassDB\", b\"class_get_method_list\")\n" \
"    _meth_get_parent_class = lib.godot_method_bind_get_method(b\"_ClassDB\", b\"get_parent_class\")\n" \
"    _meth_get_property_list = lib.godot_method_bind_get_method(b\"_ClassDB\", b\"class_get_property_list\")\n" \
"    _meth_get_integer_constant_list = lib.godot_method_bind_get_method(b\"_ClassDB\", b\"class_get_integer_constant_list\")\n" \
"    _meth_get_integer_constant = lib.godot_method_bind_get_method(b\"_ClassDB\", b\"class_get_integer_constant\")\n" \
"\n" \
"    @classmethod\n" \
"    def get_class_list(cls):\n" \
"        ret = ffi.new(\"godot_pool_string_array*\")\n" \
"        lib.godot_pool_string_array_new(ret)\n" \
"        lib.godot_method_bind_ptrcall(cls._meth_get_class_list, cls._instance, ffi.NULL, ret)\n" \
"\n" \
"        # Convert Godot return into Python civilized stuff\n" \
"        unordered = []\n" \
"        for i in range(lib.godot_pool_string_array_size(ret)):\n" \
"            godot_str = lib.godot_pool_string_array_get(ret, i)\n" \
"            c_str = lib.godot_string_c_str(ffi.new('godot_string*', godot_str))\n" \
"            unordered.append(ffi.string(c_str))\n" \
"\n" \
"        # Order class to have a parent defined before their children\n" \
"        classes = []\n" \
"        while len(unordered) != len(classes):\n" \
"            for classname in unordered:\n" \
"                parentname = cls.get_parent_class(classname)\n" \
"                if not parentname or parentname in classes:\n" \
"                    if classname not in classes:\n" \
"                        classes.append(classname)\n" \
"\n" \
"        return classes\n" \
"\n" \
"    @classmethod\n" \
"    def get_class_constructor(cls, classname):\n" \
"\n" \
"        def constructor():\n" \
"            gd_classname = ffi.new(\"godot_string*\")\n" \
"            lib.godot_string_new_data(gd_classname, classname.encode(), len(classname.encode()))\n" \
"            args = ffi.new(\"void*[]\", [gd_classname])\n" \
"            ret = ffi.new(\"godot_object*\")\n" \
"            lib.godot_method_bind_ptrcall(cls._meth_instance, cls._instance, args, ret)\n" \
"            return ret\n" \
"\n" \
"        return constructor\n" \
"\n" \
"    @classmethod\n" \
"    def get_class_methods(cls, classname):\n" \
"        methods = []\n" \
"        ret = ffi.new(\"godot_array*\")\n" \
"        gd_classname = ffi.new(\"godot_string*\")\n" \
"        lib.godot_string_new_data(gd_classname, classname.encode(), len(classname.encode()))\n" \
"        gd_true = ffi.new(\"godot_bool*\", 1)\n" \
"        args = ffi.new(\"void*[2]\", [gd_classname, gd_true])\n" \
"        # 2nd arg should be false, which what we get by not initializing it\n" \
"        lib.godot_method_bind_ptrcall(cls._meth_get_method_list, cls._instance, args, ret)\n" \
"        for i in range(lib.godot_array_size(ret)):\n" \
"            var = lib.godot_array_get(ret, i)\n" \
"            gddict = lib.godot_variant_as_dictionary(var)\n" \
"            methdict = godot_dictionary_to_pyobj(ffi.addressof(gddict))\n" \
"            methods.append(methdict)\n" \
"        return methods\n" \
"\n" \
"    @classmethod\n" \
"    def get_class_properties(cls, classname):\n" \
"        properties = []\n" \
"        ret = ffi.new(\"godot_array*\")\n" \
"        gd_classname = ffi.new(\"godot_string*\")\n" \
"        lib.godot_string_new_data(gd_classname, classname.encode(), len(classname.encode()))\n" \
"        gd_true = ffi.new(\"godot_bool*\", 1)\n" \
"        args = ffi.new(\"void*[2]\", [gd_classname, gd_true])\n" \
"        # 2nd arg should be false, which what we get by not initializing it\n" \
"        lib.godot_method_bind_ptrcall(cls._meth_get_property_list, cls._instance, args, ret)\n" \
"        for i in range(lib.godot_array_size(ret)):\n" \
"            var = lib.godot_array_get(ret, i)\n" \
"            gddict = lib.godot_variant_as_dictionary(var)\n" \
"            propdict = godot_dictionary_to_pyobj(ffi.addressof(gddict))\n" \
"            properties.append(propdict)\n" \
"        return properties\n" \
"\n" \
"    @classmethod\n" \
"    def get_class_consts(cls, classname):\n" \
"        consts = []\n" \
"        ret = ffi.new(\"godot_pool_string_array*\")\n" \
"        lib.godot_pool_string_array_new(ret)\n" \
"        gd_classname = ffi.new(\"godot_string*\")\n" \
"        gd_true = ffi.new(\"godot_bool*\", 1)\n" \
"        lib.godot_string_new_data(gd_classname, classname.encode(), len(classname.encode()))\n" \
"        args = ffi.new(\"void*[2]\", [gd_classname, gd_true])\n" \
"        # 2nd arg should be false, which what we get by not initializing it\n" \
"        lib.godot_method_bind_ptrcall(cls._meth_get_integer_constant_list, cls._instance, args, ret)\n" \
"        for i in range(lib.godot_pool_string_array_size(ret)):\n" \
"            godot_str = lib.godot_pool_string_array_get(ret, i)\n" \
"            c_str = lib.godot_string_c_str(ffi.new('godot_string*', godot_str))\n" \
"            consts.append(ffi.string(c_str))\n" \
"        return consts\n" \
"\n" \
"    @classmethod\n" \
"    def get_integer_constant(cls, classname, constname):\n" \
"        ret = ffi.new(\"godot_int*\")\n" \
"        gd_classname = ffi.new(\"godot_string*\")\n" \
"        lib.godot_string_new_data(gd_classname, classname.encode(), len(classname.encode()))\n" \
"        gd_constname = ffi.new(\"godot_string*\")\n" \
"        lib.godot_string_new_data(gd_constname, constname.encode(), len(constname.encode()))\n" \
"        args = ffi.new(\"void*[2]\", [gd_classname, gd_constname])\n" \
"        # 2nd arg should be false, which what we get by not initializing it\n" \
"        lib.godot_method_bind_ptrcall(cls._meth_get_integer_constant, cls._instance, args, ret)\n" \
"        return int(ret[0])\n" \
"\n" \
"    @classmethod\n" \
"    def get_parent_class(cls, classname):\n" \
"        ret = ffi.new(\"godot_string*\")\n" \
"        gd_classname = ffi.new(\"godot_string*\")\n" \
"        lib.godot_string_new_data(gd_classname, classname.encode(), len(classname.encode()))\n" \
"        args = ffi.new(\"godot_string**\", gd_classname)\n" \
"        lib.godot_method_bind_ptrcall(cls._meth_get_parent_class, cls._instance, ffi.cast(\"void**\", args), ret)\n" \
"        c_str = lib.godot_string_c_str(ret)\n" \
"        return ffi.string(c_str)\n" \
"\n" \
"\n" \
"class BaseObject:\n" \
"    def __init__(self, gd_obj=None):\n" \
"        self._gd_obj = gd_obj if gd_obj else self._gd_constructor()\n" \
"\n" \
"    def _gd_set_godot_obj(self, obj):\n" \
"        self._gd_obj = obj\n" \
"\n" \
"    def __eq__(self, other):\n" \
"        if hasattr(other, '_gd_obj'):\n" \
"            return self._gd_obj == other._gd_obj\n" \
"        else:\n" \
"            return False\n" \
"\n" \
"\n" \
"# TODO: use pybind11 for this \?\n" \
"class Vector2:\n" \
"    def __init__(self, x=0.0, y=0.0):\n" \
"        self._gd_obj = ffi.new('godot_vector2*')\n" \
"        lib.godot_vector2_new(self._gd_obj, x, y)\n" \
"\n" \
"    @property\n" \
"    def x(self):\n" \
"        return lib.godot_vector2_get_x(self._gd_obj)\n" \
"\n" \
"    @property\n" \
"    def y(self):\n" \
"        return lib.godot_vector2_get_y(self._gd_obj)\n" \
"\n" \
"    @x.setter\n" \
"    def x(self, val):\n" \
"        lib.godot_vector2_set_x(self._gd_obj, val)\n" \
"\n" \
"    @y.setter\n" \
"    def y(self, val):\n" \
"        lib.godot_vector2_set_y(self._gd_obj, val)\n" \
"\n" \
"    @property\n" \
"    def width(self):\n" \
"        return self.x\n" \
"\n" \
"    @property\n" \
"    def height(self):\n" \
"        return self.y\n" \
"\n" \
"    @width.setter\n" \
"    def width(self, val):\n" \
"        self.x = val\n" \
"\n" \
"    @height.setter\n" \
"    def height(self, val):\n" \
"        self.y = val\n" \
"\n" \
"    def __repr__(self):\n" \
"        return \"<%s(x=%s, y=%s)>\" % (type(self).__name__, self.x, self.y)\n" \
"\n" \
"    def __eq__(self, other):\n" \
"        return isinstance(other, Vector2) and other.x == self.x and other.y == self.y\n" \
"\n" \
"    def __neg__(self):\n" \
"        return type(self)(-self.x, -self.y)\n" \
"\n" \
"    def __pos__(self):\n" \
"        return self\n" \
"\n" \
"\n" \
"def _gen_stub(msg):\n" \
"    return lambda *args: print(msg)\n" \
"\n" \
"\n" \
"def build_method(classname, meth):\n" \
"    methname = meth['name']\n" \
"    # Flag METHOD_FLAG_VIRTUAL only available when compiling godot with DEBUG_METHODS_ENABLED\n" \
"    methbind = lib.godot_method_bind_get_method(classname.encode(), methname.encode())\n" \
"    if meth['flags'] & lib.METHOD_FLAG_VIRTUAL or methbind == ffi.NULL:\n" \
"        def bind(self, *args):\n" \
"            raise NotImplementedError()\n" \
"    else:\n" \
"        def bind(self, *args):\n" \
"            # TODO: check args number and type here (ptrcall means segfault on bad args...)\n" \
"            print('++++ Calling %s.%s (%s) on %s with %s' % (classname, methname, meth, self, args))\n" \
"            # TODO: check len(args)\n" \
"            raw_args = [pyobj_to_raw(meth_arg['type'], arg)\n" \
"                        for arg, meth_arg in zip(args, meth['args'])]\n" \
"            # args_as_variants = [pyobj_to_variant(arg) for arg in args]\n" \
"            gdargs = ffi.new(\"void*[]\", raw_args) if raw_args else ffi.NULL\n" \
"            ret = new_raw(meth['return']['type'])\n" \
"            print('==============================>>>', methbind, self._gd_obj, gdargs, ret)\n" \
"            lib.godot_method_bind_ptrcall(methbind, self._gd_obj, gdargs, ret)\n" \
"            return raw_to_pyobj(meth['return']['type'], ret, meth['return']['hint_string'])\n" \
"\n" \
"    return bind\n" \
"\n" \
"\n" \
"def build_property(classname, prop):\n" \
"    propname = prop['name']\n" \
"    getbind = lib.godot_method_bind_get_method(classname.encode(), propname.encode())\n" \
"    ######################### BUG getbind is NULL !!!\n" \
"\n" \
"    def getter(self):\n" \
"        print('++++ Property GET %s.%s (%s) on %s' % (classname, propname, prop, self))\n" \
"        ret = new_raw(prop['type'])\n" \
"        print('==============================>>>', getbind, self._gd_obj, ffi.NULL, ret)\n" \
"        lib.godot_method_bind_ptrcall(getbind, self._gd_obj, ffi.NULL, ret)\n" \
"        return raw_to_pyobj(prop['type'], ret, prop['hint_string'])\n" \
"\n" \
"    def setter(self, value):\n" \
"        print('++++ Property SET %s.%s (%s) on %s with %s' % (classname, propname, prop, self, value))\n" \
"        gdvalue = pyobj_to_raw(prop['type'], value, prop['hint_string'])\n" \
"        gdargs = ffi.new(\"void*[]\", [gdvalue])\n" \
"        ret = new_raw(prop['type'])\n" \
"        print('==============================>>>', getbind, self._gd_obj, ffi.NULL, ret)\n" \
"        lib.godot_method_bind_ptrcall(getbind, self._gd_obj, gdargs, ret)\n" \
"        return raw_to_pyobj(prop['type'], ret, prop['hint_string'])\n" \
"\n" \
"    propobj = property(getter)\n" \
"    return propobj.setter(setter)\n" \
"\n" \
"\n" \
"def build_class(classname, binding_classname=None):\n" \
"    binding_classname = binding_classname or classname\n" \
"    nmspc = {\n" \
"        '_gd_name': classname,\n" \
"        '_gd_constructor': ClassDB.get_class_constructor(classname)\n" \
"    }\n" \
"    print('======> BINDING', classname)\n" \
"    # Methods\n" \
"    for meth in ClassDB.get_class_methods(classname):\n" \
"        print('=> M', meth['name'])\n" \
"        nmspc[meth['name']] = build_method(classname, meth)\n" \
"    # Properties\n" \
"    for prop in ClassDB.get_class_properties(classname):\n" \
"        propname = prop['name']\n" \
"        print('=> P', propname)\n" \
"        nmspc[propname] = build_property(classname, prop)\n" \
"    # Constants\n" \
"    for constname in ClassDB.get_class_consts(classname):\n" \
"        nmspc[constname] = ClassDB.get_integer_constant(classname, constname)\n" \
"        print('=> C', constname)\n" \
"    parentname = ClassDB.get_parent_class(classname)\n" \
"    print('=> P', parentname)\n" \
"    if parentname:\n" \
"        bases = (getattr(module, parentname), )\n" \
"    else:\n" \
"        bases = (BaseObject, )\n" \
"    return type(binding_classname, bases, nmspc)\n" \
"\n" \
"\n" \
"def build_global(name, clsname):\n" \
"    return getattr(module, clsname)(lib.godot_global_get_singleton(name.encode()))\n" \
"\n" \
"\n" \
"# Werkzeug style lazy module\n" \
"class LazyBindingsModule(ModuleType):\n" \
"\n" \
"    \"\"\"Automatically import objects from the modules.\"\"\"\n" \
"\n" \
"    def _bootstrap_global_singletons(self):\n" \
"        # Special classes generated in `godot/core/core_bind.h`, classname\n" \
"        # has a \"_\" prefix\n" \
"        for clsname, name in (\n" \
"                ('_ResourceLoader', 'ResourceLoader'),\n" \
"                ('_ResourceSaver', 'ResourceSaver'),\n" \
"                ('_OS', 'OS'),\n" \
"                ('_Geometry', 'Geometry'),\n" \
"                ('_ClassDB', 'ClassDB'),\n" \
"                ('_Engine', 'Engine'),):\n" \
"            self._available[name] = partial(build_global, name, clsname)\n" \
"        # Regular classses, we have to rename the classname with a \"_\" prefix\n" \
"        # to give the name to the singleton\n" \
"        # TODO: GlobalConfig doesn't provide a `list_singletons` to load\n" \
"        # this dynamically :'-(\n" \
"        for new_clsname, name in (\n" \
"                ('_AudioServer', 'AudioServer'),\n" \
"                ('_AudioServer', 'AS'),\n" \
"                ('_GlobalConfig', 'GlobalConfig'),\n" \
"                ('_IP', 'IP'),\n" \
"                ('_Input', 'Input'),\n" \
"                ('_InputMap', 'InputMap'),\n" \
"                ('_Marshalls', 'Marshalls'),\n" \
"                # TODO: seems to have been removed...\n" \
"                # ('_PathRemap', 'PathRemap'),\n" \
"                ('_Performance', 'Performance'),\n" \
"                ('_Physics2DServer', 'Physics2DServer'),\n" \
"                ('_Physics2DServer', 'PS2D'),\n" \
"                ('_PhysicsServer', 'PhysicsServer'),\n" \
"                ('_PhysicsServer', 'PS'),\n" \
"                # TODO: seems to have been removed...\n" \
"                # ('_SpatialSound2DServer', 'SpatialSound2DServer'),\n" \
"                # ('_SpatialSound2DServer', 'SS2D'),\n" \
"                # ('_SpatialSoundServer', 'SpatialSoundServer'),\n" \
"                # ('_SpatialSoundServer', 'SS'),\n" \
"                ('_TranslationServer', 'TranslationServer'),\n" \
"                ('_TranslationServer', 'TS'),\n" \
"                ('_VisualServer', 'VisualServer'),\n" \
"                ('_VisualServer', 'VS')):\n" \
"            if new_clsname not in self._available:\n" \
"                self._available[new_clsname] = self._available[name]\n" \
"            self._available[name] = partial(build_global, name, new_clsname)\n" \
"\n" \
"    def __init__(self, name, doc=None):\n" \
"        super().__init__(name, doc=doc)\n" \
"        self._loaded = {'Vector2': Vector2}\n" \
"        # Load global constants\n" \
"        self._loaded.update(GlobalConstants.get_global_constansts())\n" \
"        # Register classe types\n" \
"        self._available = {name: partial(build_class, name) for name in ClassDB.get_class_list()}\n" \
"        self._bootstrap_global_singletons()\n" \
"        # self._bootstrap_builtins()\n" \
"        setattr(self, '__package__', name)\n" \
"        setattr(self, '__all__', list(self._loaded.keys()) + list(self._available.keys()))\n" \
"\n" \
"    def __getattr__(self, name):\n" \
"        if name not in self._loaded:\n" \
"            loader = self._available.get(name)\n" \
"            if not loader:\n" \
"                return ModuleType.__getattribute__(self, name)\n" \
"            self._loaded[name] = loader()\n" \
"        return self._loaded[name]\n" \
"\n" \
"    def __dir__(self):\n" \
"        \"\"\"Just show what we want to show.\"\"\"\n" \
"        result = list(self.__all__)\n" \
"        result.extend(('__all__', '__doc__', '__loader__', '__name__',\n" \
"                       '__package__', '__spec__', '_available', '_loaded'))\n" \
"        return result\n" \
"\n" \
"\n" \
"module = LazyBindingsModule(\"godot.bindings\")\n" \
"sys.modules[\"godot.bindings\"] = module\n" \
"\n" \
"\n"
#ifdef PYPY_VERSION
# define _CFFI_PYTHON_STARTUP_FUNC  _cffi_pypyinit_pythonscriptcffi
#elif PY_MAJOR_VERSION >= 3
# define _CFFI_PYTHON_STARTUP_FUNC  PyInit_pythonscriptcffi
#else
# define _CFFI_PYTHON_STARTUP_FUNC  initpythonscriptcffi
#endif

/***** Support code for embedding *****/

#if defined(_MSC_VER)
#  define CFFI_DLLEXPORT  __declspec(dllexport)
#elif defined(__GNUC__)
#  define CFFI_DLLEXPORT  __attribute__((visibility("default")))
#else
#  define CFFI_DLLEXPORT  /* nothing */
#endif


/* There are two global variables of type _cffi_call_python_fnptr:

   * _cffi_call_python, which we declare just below, is the one called
     by ``extern "Python"`` implementations.

   * _cffi_call_python_org, which on CPython is actually part of the
     _cffi_exports[] array, is the function pointer copied from
     _cffi_backend.

   After initialization is complete, both are equal.  However, the
   first one remains equal to &_cffi_start_and_call_python until the
   very end of initialization, when we are (or should be) sure that
   concurrent threads also see a completely initialized world, and
   only then is it changed.
*/
#undef _cffi_call_python
typedef void (*_cffi_call_python_fnptr)(struct _cffi_externpy_s *, char *);
static void _cffi_start_and_call_python(struct _cffi_externpy_s *, char *);
static _cffi_call_python_fnptr _cffi_call_python = &_cffi_start_and_call_python;


#ifndef _MSC_VER
   /* --- Assuming a GCC not infinitely old --- */
# define cffi_compare_and_swap(l,o,n)  __sync_bool_compare_and_swap(l,o,n)
# define cffi_write_barrier()          __sync_synchronize()
# if !defined(__amd64__) && !defined(__x86_64__) &&   \
     !defined(__i386__) && !defined(__i386)
#   define cffi_read_barrier()         __sync_synchronize()
# else
#   define cffi_read_barrier()         (void)0
# endif
#else
   /* --- Windows threads version --- */
# include <Windows.h>
# define cffi_compare_and_swap(l,o,n) \
                               (InterlockedCompareExchangePointer(l,n,o) == (o))
# define cffi_write_barrier()       InterlockedCompareExchange(&_cffi_dummy,0,0)
# define cffi_read_barrier()           (void)0
static volatile LONG _cffi_dummy;
#endif

#ifdef WITH_THREAD
# ifndef _MSC_VER
#  include <pthread.h>
   static pthread_mutex_t _cffi_embed_startup_lock;
# else
   static CRITICAL_SECTION _cffi_embed_startup_lock;
# endif
  static char _cffi_embed_startup_lock_ready = 0;
#endif

static void _cffi_acquire_reentrant_mutex(void)
{
    static void *volatile lock = NULL;

    while (!cffi_compare_and_swap(&lock, NULL, (void *)1)) {
        /* should ideally do a spin loop instruction here, but
           hard to do it portably and doesn't really matter I
           think: pthread_mutex_init() should be very fast, and
           this is only run at start-up anyway. */
    }

#ifdef WITH_THREAD
    if (!_cffi_embed_startup_lock_ready) {
# ifndef _MSC_VER
        pthread_mutexattr_t attr;
        pthread_mutexattr_init(&attr);
        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
        pthread_mutex_init(&_cffi_embed_startup_lock, &attr);
# else
        InitializeCriticalSection(&_cffi_embed_startup_lock);
# endif
        _cffi_embed_startup_lock_ready = 1;
    }
#endif

    while (!cffi_compare_and_swap(&lock, (void *)1, NULL))
        ;

#ifndef _MSC_VER
    pthread_mutex_lock(&_cffi_embed_startup_lock);
#else
    EnterCriticalSection(&_cffi_embed_startup_lock);
#endif
}

static void _cffi_release_reentrant_mutex(void)
{
#ifndef _MSC_VER
    pthread_mutex_unlock(&_cffi_embed_startup_lock);
#else
    LeaveCriticalSection(&_cffi_embed_startup_lock);
#endif
}


/**********  CPython-specific section  **********/
#ifndef PYPY_VERSION


#define _cffi_call_python_org  _cffi_exports[_CFFI_CPIDX]

PyMODINIT_FUNC _CFFI_PYTHON_STARTUP_FUNC(void);   /* forward */

static void _cffi_py_initialize(void)
{
    /* XXX use initsigs=0, which "skips initialization registration of
       signal handlers, which might be useful when Python is
       embedded" according to the Python docs.  But review and think
       if it should be a user-controllable setting.

       XXX we should also give a way to write errors to a buffer
       instead of to stderr.

       XXX if importing 'site' fails, CPython (any version) calls
       exit().  Should we try to work around this behavior here?
    */
    Py_InitializeEx(0);
}

static int _cffi_initialize_python(void)
{
    /* This initializes Python, imports _cffi_backend, and then the
       present .dll/.so is set up as a CPython C extension module.
    */
    int result;
    PyGILState_STATE state;
    PyObject *pycode=NULL, *global_dict=NULL, *x;

#if PY_MAJOR_VERSION >= 3
    /* see comments in _cffi_carefully_make_gil() about the
       Python2/Python3 difference 
    */
#else
    /* Acquire the GIL.  We have no threadstate here.  If Python is 
       already initialized, it is possible that there is already one
       existing for this thread, but it is not made current now.
    */
    PyEval_AcquireLock();

    _cffi_py_initialize();

    /* The Py_InitializeEx() sometimes made a threadstate for us, but
       not always.  Indeed Py_InitializeEx() could be called and do
       nothing.  So do we have a threadstate, or not?  We don't know,
       but we can replace it with NULL in all cases.
    */
    (void)PyThreadState_Swap(NULL);

    /* Now we can release the GIL and re-acquire immediately using the
       logic of PyGILState(), which handles making or installing the
       correct threadstate.
    */
    PyEval_ReleaseLock();
#endif
    state = PyGILState_Ensure();

    /* Call the initxxx() function from the present module.  It will
       create and initialize us as a CPython extension module, instead
       of letting the startup Python code do it---it might reimport
       the same .dll/.so and get maybe confused on some platforms.
       It might also have troubles locating the .dll/.so again for all
       I know.
    */
    (void)_CFFI_PYTHON_STARTUP_FUNC();
    if (PyErr_Occurred())
        goto error;

    /* Now run the Python code provided to ffi.embedding_init_code().
     */
    pycode = Py_CompileString(_CFFI_PYTHON_STARTUP_CODE,
                              "<init code for '" _CFFI_MODULE_NAME "'>",
                              Py_file_input);
    if (pycode == NULL)
        goto error;
    global_dict = PyDict_New();
    if (global_dict == NULL)
        goto error;
    if (PyDict_SetItemString(global_dict, "__builtins__",
                             PyThreadState_GET()->interp->builtins) < 0)
        goto error;
    x = PyEval_EvalCode(
#if PY_MAJOR_VERSION < 3
                        (PyCodeObject *)
#endif
                        pycode, global_dict, global_dict);
    if (x == NULL)
        goto error;
    Py_DECREF(x);

    /* Done!  Now if we've been called from
       _cffi_start_and_call_python() in an ``extern "Python"``, we can
       only hope that the Python code did correctly set up the
       corresponding @ffi.def_extern() function.  Otherwise, the
       general logic of ``extern "Python"`` functions (inside the
       _cffi_backend module) will find that the reference is still
       missing and print an error.
     */
    result = 0;
 done:
    Py_XDECREF(pycode);
    Py_XDECREF(global_dict);
    PyGILState_Release(state);
    return result;

 error:;
    {
        /* Print as much information as potentially useful.
           Debugging load-time failures with embedding is not fun
        */
        PyObject *exception, *v, *tb, *f, *modules, *mod;
        PyErr_Fetch(&exception, &v, &tb);
        if (exception != NULL) {
            PyErr_NormalizeException(&exception, &v, &tb);
            PyErr_Display(exception, v, tb);
        }
        Py_XDECREF(exception);
        Py_XDECREF(v);
        Py_XDECREF(tb);

        f = PySys_GetObject((char *)"stderr");
        if (f != NULL && f != Py_None) {
            PyFile_WriteString("\nFrom: " _CFFI_MODULE_NAME
                               "\ncompiled with cffi version: 1.9.1"
                               "\n_cffi_backend module: ", f);
            modules = PyImport_GetModuleDict();
            mod = PyDict_GetItemString(modules, "_cffi_backend");
            if (mod == NULL) {
                PyFile_WriteString("not loaded", f);
            }
            else {
                v = PyObject_GetAttrString(mod, "__file__");
                PyFile_WriteObject(v, f, 0);
                Py_XDECREF(v);
            }
            PyFile_WriteString("\nsys.path: ", f);
            PyFile_WriteObject(PySys_GetObject((char *)"path"), f, 0);
            PyFile_WriteString("\n\n", f);
        }
    }
    result = -1;
    goto done;
}

PyAPI_DATA(char *) _PyParser_TokenNames[];  /* from CPython */

static int _cffi_carefully_make_gil(void)
{
    /* This does the basic initialization of Python.  It can be called
       completely concurrently from unrelated threads.  It assumes
       that we don't hold the GIL before (if it exists), and we don't
       hold it afterwards.

       What it really does is completely different in Python 2 and 
       Python 3.

    Python 2
    ========

       Initialize the GIL, without initializing the rest of Python,
       by calling PyEval_InitThreads().

       PyEval_InitThreads() must not be called concurrently at all.
       So we use a global variable as a simple spin lock.  This global
       variable must be from 'libpythonX.Y.so', not from this
       cffi-based extension module, because it must be shared from
       different cffi-based extension modules.  We choose
       _PyParser_TokenNames[0] as a completely arbitrary pointer value
       that is never written to.  The default is to point to the
       string "ENDMARKER".  We change it temporarily to point to the
       next character in that string.  (Yes, I know it's REALLY
       obscure.)

    Python 3
    ========

       In Python 3, PyEval_InitThreads() cannot be called before
       Py_InitializeEx() any more.  So this function calls
       Py_InitializeEx() first.  It uses the same obscure logic to
       make sure we never call it concurrently.

       Arguably, this is less good on the spinlock, because
       Py_InitializeEx() takes much longer to run than
       PyEval_InitThreads().  But I didn't find a way around it.
    */

#ifdef WITH_THREAD
    char *volatile *lock = (char *volatile *)_PyParser_TokenNames;
    char *old_value;

    while (1) {    /* spin loop */
        old_value = *lock;
        if (old_value[0] == 'E') {
            assert(old_value[1] == 'N');
            if (cffi_compare_and_swap(lock, old_value, old_value + 1))
                break;
        }
        else {
            assert(old_value[0] == 'N');
            /* should ideally do a spin loop instruction here, but
               hard to do it portably and doesn't really matter I
               think: PyEval_InitThreads() should be very fast, and
               this is only run at start-up anyway. */
        }
    }
#endif

#if PY_MAJOR_VERSION >= 3
    /* Python 3: call Py_InitializeEx() */
    {
        PyGILState_STATE state = PyGILState_UNLOCKED;
        if (!Py_IsInitialized())
            _cffi_py_initialize();
        else
            state = PyGILState_Ensure();

        PyEval_InitThreads();
        PyGILState_Release(state);
    }
#else
    /* Python 2: call PyEval_InitThreads() */
# ifdef WITH_THREAD
    if (!PyEval_ThreadsInitialized()) {
        PyEval_InitThreads();    /* makes the GIL */
        PyEval_ReleaseLock();    /* then release it */
    }
    /* else: there is already a GIL, but we still needed to do the
       spinlock dance to make sure that we see it as fully ready */
# endif
#endif

#ifdef WITH_THREAD
    /* release the lock */
    while (!cffi_compare_and_swap(lock, old_value + 1, old_value))
        ;
#endif

    return 0;
}

/**********  end CPython-specific section  **********/


#else


/**********  PyPy-specific section  **********/

PyMODINIT_FUNC _CFFI_PYTHON_STARTUP_FUNC(const void *[]);   /* forward */

static struct _cffi_pypy_init_s {
    const char *name;
    void (*func)(const void *[]);
    const char *code;
} _cffi_pypy_init = {
    _CFFI_MODULE_NAME,
    (void(*)(const void *[]))_CFFI_PYTHON_STARTUP_FUNC,
    _CFFI_PYTHON_STARTUP_CODE,
};

extern int pypy_carefully_make_gil(const char *);
extern int pypy_init_embedded_cffi_module(int, struct _cffi_pypy_init_s *);

static int _cffi_carefully_make_gil(void)
{
    return pypy_carefully_make_gil(_CFFI_MODULE_NAME);
}

static int _cffi_initialize_python(void)
{
    return pypy_init_embedded_cffi_module(0xB011, &_cffi_pypy_init);
}

/**********  end PyPy-specific section  **********/


#endif


#ifdef __GNUC__
__attribute__((noinline))
#endif
static _cffi_call_python_fnptr _cffi_start_python(void)
{
    /* Delicate logic to initialize Python.  This function can be
       called multiple times concurrently, e.g. when the process calls
       its first ``extern "Python"`` functions in multiple threads at
       once.  It can also be called recursively, in which case we must
       ignore it.  We also have to consider what occurs if several
       different cffi-based extensions reach this code in parallel
       threads---it is a different copy of the code, then, and we
       can't have any shared global variable unless it comes from
       'libpythonX.Y.so'.

       Idea:

       * _cffi_carefully_make_gil(): "carefully" call
         PyEval_InitThreads() (possibly with Py_InitializeEx() first).

       * then we use a (local) custom lock to make sure that a call to this
         cffi-based extension will wait if another call to the *same*
         extension is running the initialization in another thread.
         It is reentrant, so that a recursive call will not block, but
         only one from a different thread.

       * then we grab the GIL and (Python 2) we call Py_InitializeEx().
         At this point, concurrent calls to Py_InitializeEx() are not
         possible: we have the GIL.

       * do the rest of the specific initialization, which may
         temporarily release the GIL but not the custom lock.
         Only release the custom lock when we are done.
    */
    static char called = 0;

    if (_cffi_carefully_make_gil() != 0)
        return NULL;

    _cffi_acquire_reentrant_mutex();

    /* Here the GIL exists, but we don't have it.  We're only protected
       from concurrency by the reentrant mutex. */

    /* This file only initializes the embedded module once, the first
       time this is called, even if there are subinterpreters. */
    if (!called) {
        called = 1;  /* invoke _cffi_initialize_python() only once,
                        but don't set '_cffi_call_python' right now,
                        otherwise concurrent threads won't call
                        this function at all (we need them to wait) */
        if (_cffi_initialize_python() == 0) {
            /* now initialization is finished.  Switch to the fast-path. */

            /* We would like nobody to see the new value of
               '_cffi_call_python' without also seeing the rest of the
               data initialized.  However, this is not possible.  But
               the new value of '_cffi_call_python' is the function
               'cffi_call_python()' from _cffi_backend.  So:  */
            cffi_write_barrier();
            /* ^^^ we put a write barrier here, and a corresponding
               read barrier at the start of cffi_call_python().  This
               ensures that after that read barrier, we see everything
               done here before the write barrier.
            */

            assert(_cffi_call_python_org != NULL);
            _cffi_call_python = (_cffi_call_python_fnptr)_cffi_call_python_org;
        }
        else {
            /* initialization failed.  Reset this to NULL, even if it was
               already set to some other value.  Future calls to
               _cffi_start_python() are still forced to occur, and will
               always return NULL from now on. */
            _cffi_call_python_org = NULL;
        }
    }

    _cffi_release_reentrant_mutex();

    return (_cffi_call_python_fnptr)_cffi_call_python_org;
}

static
void _cffi_start_and_call_python(struct _cffi_externpy_s *externpy, char *args)
{
    _cffi_call_python_fnptr fnptr;
    int current_err = errno;
#ifdef _MSC_VER
    int current_lasterr = GetLastError();
#endif
    fnptr = _cffi_start_python();
    if (fnptr == NULL) {
        fprintf(stderr, "function %s() called, but initialization code "
                        "failed.  Returning 0.\n", externpy->name);
        memset(args, 0, externpy->size_of_result);
    }
#ifdef _MSC_VER
    SetLastError(current_lasterr);
#endif
    errno = current_err;

    if (fnptr != NULL)
        fnptr(externpy, args);
}


/* The cffi_start_python() function makes sure Python is initialized
   and our cffi module is set up.  It can be called manually from the
   user C code.  The same effect is obtained automatically from any
   dll-exported ``extern "Python"`` function.  This function returns
   -1 if initialization failed, 0 if all is OK.  */
_CFFI_UNUSED_FN
static int cffi_start_python(void)
{
    if (_cffi_call_python == &_cffi_start_and_call_python) {
        if (_cffi_start_python() == NULL)
            return -1;
    }
    cffi_read_barrier();
    return 0;
}

#undef cffi_compare_and_swap
#undef cffi_write_barrier
#undef cffi_read_barrier

/************************************************************/


#include "Include/Python.h"
#include "modules/dlscript/godot.h"
// TODO: MethodFlags not in ldscript headers
enum MethodFlags {
    METHOD_FLAG_NORMAL=1,
    METHOD_FLAG_EDITOR=2,
    METHOD_FLAG_NOSCRIPT=4,
    METHOD_FLAG_CONST=8,
    METHOD_FLAG_REVERSE=16, // used for events
    METHOD_FLAG_VIRTUAL=32,
    METHOD_FLAG_FROM_SCRIPT=64,
    METHOD_FLAG_VARARG=128,
    METHOD_FLAGS_DEFAULT=METHOD_FLAG_NORMAL,
};

// TODO: waiting for dlscript to implement this (https://github.com/godotengine/godot/issues/8316)
#include "core/global_constants.h"
const int godot_get_global_constant_count() {
       return GlobalConstants::get_global_constant_count();
}

const char *godot_get_global_constant_name(int index) {
       return GlobalConstants::get_global_constant_name(index);
}

int godot_get_global_constant_value(int index) {
       return GlobalConstants::get_global_constant_value(index);
}


/************************************************************/

static void *_cffi_types[] = {
/*  0 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // PyObject *()(PyObject *)
/*  1 */ _CFFI_OP(_CFFI_OP_POINTER, 323), // PyObject *
/*  2 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  3 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // PyObject *()(PyObject *, void *)
/*  4 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/*  5 */ _CFFI_OP(_CFFI_OP_POINTER, 350), // void *
/*  6 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  7 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // PyObject *()(void * *, int)
/*  8 */ _CFFI_OP(_CFFI_OP_POINTER, 5), // void * *
/*  9 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7), // int
/* 10 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 11 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // PyObject *()(void *)
/* 12 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 13 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 14 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // PyObject *()(wchar_t *)
/* 15 */ _CFFI_OP(_CFFI_OP_POINTER, 351), // wchar_t *
/* 16 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 17 */ _CFFI_OP(_CFFI_OP_FUNCTION, 266), // _Bool()(godot_array const *)
/* 18 */ _CFFI_OP(_CFFI_OP_POINTER, 327), // godot_array const *
/* 19 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 20 */ _CFFI_OP(_CFFI_OP_FUNCTION, 266), // _Bool()(godot_array const *, godot_variant const *)
/* 21 */ _CFFI_OP(_CFFI_OP_NOOP, 18),
/* 22 */ _CFFI_OP(_CFFI_OP_POINTER, 333), // godot_variant const *
/* 23 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 24 */ _CFFI_OP(_CFFI_OP_FUNCTION, 266), // _Bool()(godot_dictionary const *)
/* 25 */ _CFFI_OP(_CFFI_OP_POINTER, 328), // godot_dictionary const *
/* 26 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 27 */ _CFFI_OP(_CFFI_OP_FUNCTION, 266), // _Bool()(godot_dictionary const *, godot_array const *)
/* 28 */ _CFFI_OP(_CFFI_OP_NOOP, 25),
/* 29 */ _CFFI_OP(_CFFI_OP_NOOP, 18),
/* 30 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 31 */ _CFFI_OP(_CFFI_OP_FUNCTION, 266), // _Bool()(godot_dictionary const *, godot_variant const *)
/* 32 */ _CFFI_OP(_CFFI_OP_NOOP, 25),
/* 33 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 34 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 35 */ _CFFI_OP(_CFFI_OP_FUNCTION, 266), // _Bool()(godot_string const *, godot_string const *)
/* 36 */ _CFFI_OP(_CFFI_OP_POINTER, 331), // godot_string const *
/* 37 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 38 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 39 */ _CFFI_OP(_CFFI_OP_FUNCTION, 266), // _Bool()(godot_variant *, godot_string const *)
/* 40 */ _CFFI_OP(_CFFI_OP_POINTER, 333), // godot_variant *
/* 41 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 42 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 43 */ _CFFI_OP(_CFFI_OP_FUNCTION, 266), // _Bool()(godot_variant const *)
/* 44 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 45 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 46 */ _CFFI_OP(_CFFI_OP_FUNCTION, 266), // _Bool()(godot_variant const *, _Bool *)
/* 47 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 48 */ _CFFI_OP(_CFFI_OP_POINTER, 266), // _Bool *
/* 49 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 50 */ _CFFI_OP(_CFFI_OP_FUNCTION, 266), // _Bool()(godot_variant const *, godot_variant const *)
/* 51 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 52 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 53 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 54 */ _CFFI_OP(_CFFI_OP_FUNCTION, 80), // char const *()(int)
/* 55 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 56 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 57 */ _CFFI_OP(_CFFI_OP_FUNCTION, 326), // enum godot_variant_type()(godot_variant const *)
/* 58 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 59 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 60 */ _CFFI_OP(_CFFI_OP_FUNCTION, 289), // float()(godot_variant const *)
/* 61 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 62 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 63 */ _CFFI_OP(_CFFI_OP_FUNCTION, 289), // float()(godot_vector2 const *)
/* 64 */ _CFFI_OP(_CFFI_OP_POINTER, 334), // godot_vector2 const *
/* 65 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 66 */ _CFFI_OP(_CFFI_OP_FUNCTION, 289), // float()(godot_vector2 const *, godot_vector2 const *)
/* 67 */ _CFFI_OP(_CFFI_OP_NOOP, 64),
/* 68 */ _CFFI_OP(_CFFI_OP_NOOP, 64),
/* 69 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 70 */ _CFFI_OP(_CFFI_OP_FUNCTION, 327), // godot_array()(godot_dictionary const *)
/* 71 */ _CFFI_OP(_CFFI_OP_NOOP, 25),
/* 72 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 73 */ _CFFI_OP(_CFFI_OP_FUNCTION, 327), // godot_array()(godot_variant const *)
/* 74 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 75 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 76 */ _CFFI_OP(_CFFI_OP_FUNCTION, 328), // godot_dictionary()(godot_variant const *)
/* 77 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 78 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 79 */ _CFFI_OP(_CFFI_OP_FUNCTION, 210), // godot_method_bind *()(char const *, char const *)
/* 80 */ _CFFI_OP(_CFFI_OP_POINTER, 324), // char const *
/* 81 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 82 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 83 */ _CFFI_OP(_CFFI_OP_FUNCTION, 331), // godot_string()(godot_dictionary const *)
/* 84 */ _CFFI_OP(_CFFI_OP_NOOP, 25),
/* 85 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 86 */ _CFFI_OP(_CFFI_OP_FUNCTION, 331), // godot_string()(godot_pool_string_array *, int)
/* 87 */ _CFFI_OP(_CFFI_OP_POINTER, 330), // godot_pool_string_array *
/* 88 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 89 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 90 */ _CFFI_OP(_CFFI_OP_FUNCTION, 331), // godot_string()(godot_variant const *)
/* 91 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 92 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 93 */ _CFFI_OP(_CFFI_OP_FUNCTION, 40), // godot_variant *()(PyObject *, godot_variant const * *, int)
/* 94 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 95 */ _CFFI_OP(_CFFI_OP_POINTER, 22), // godot_variant const * *
/* 96 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 97 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 98 */ _CFFI_OP(_CFFI_OP_FUNCTION, 40), // godot_variant *()(godot_array *, int)
/* 99 */ _CFFI_OP(_CFFI_OP_POINTER, 327), // godot_array *
/* 100 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 101 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 102 */ _CFFI_OP(_CFFI_OP_FUNCTION, 40), // godot_variant *()(godot_dictionary *, godot_variant const *)
/* 103 */ _CFFI_OP(_CFFI_OP_POINTER, 328), // godot_dictionary *
/* 104 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 105 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 106 */ _CFFI_OP(_CFFI_OP_FUNCTION, 333), // godot_variant()(godot_array *)
/* 107 */ _CFFI_OP(_CFFI_OP_NOOP, 99),
/* 108 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 109 */ _CFFI_OP(_CFFI_OP_FUNCTION, 333), // godot_variant()(godot_array const *)
/* 110 */ _CFFI_OP(_CFFI_OP_NOOP, 18),
/* 111 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 112 */ _CFFI_OP(_CFFI_OP_FUNCTION, 333), // godot_variant()(godot_variant *, godot_string const *, godot_variant const * *, int)
/* 113 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 114 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 115 */ _CFFI_OP(_CFFI_OP_NOOP, 95),
/* 116 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 117 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 118 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // int()(godot_array *, godot_variant const *)
/* 119 */ _CFFI_OP(_CFFI_OP_NOOP, 99),
/* 120 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 121 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 122 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // int()(godot_array const *)
/* 123 */ _CFFI_OP(_CFFI_OP_NOOP, 18),
/* 124 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 125 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // int()(godot_array const *, godot_variant const *)
/* 126 */ _CFFI_OP(_CFFI_OP_NOOP, 18),
/* 127 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 128 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 129 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // int()(godot_array const *, godot_variant const *, int)
/* 130 */ _CFFI_OP(_CFFI_OP_NOOP, 18),
/* 131 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 132 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 133 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 134 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // int()(godot_dictionary *, godot_string const *)
/* 135 */ _CFFI_OP(_CFFI_OP_NOOP, 103),
/* 136 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 137 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 138 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // int()(godot_dictionary const *)
/* 139 */ _CFFI_OP(_CFFI_OP_NOOP, 25),
/* 140 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 141 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // int()(godot_pool_string_array *)
/* 142 */ _CFFI_OP(_CFFI_OP_NOOP, 87),
/* 143 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 144 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // int()(godot_pool_string_array *, int, godot_string const *)
/* 145 */ _CFFI_OP(_CFFI_OP_NOOP, 87),
/* 146 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 147 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 148 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 149 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // int()(int)
/* 150 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 151 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 152 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // int()(int, int)
/* 153 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 154 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 155 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 156 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // int()(void)
/* 157 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 158 */ _CFFI_OP(_CFFI_OP_FUNCTION, 336), // uint32_t()(godot_array const *)
/* 159 */ _CFFI_OP(_CFFI_OP_NOOP, 18),
/* 160 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 161 */ _CFFI_OP(_CFFI_OP_FUNCTION, 336), // uint32_t()(godot_dictionary const *)
/* 162 */ _CFFI_OP(_CFFI_OP_NOOP, 25),
/* 163 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 164 */ _CFFI_OP(_CFFI_OP_FUNCTION, 282), // uint64_t()(godot_variant const *)
/* 165 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 166 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 167 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // void *()(char *)
/* 168 */ _CFFI_OP(_CFFI_OP_POINTER, 324), // char *
/* 169 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 170 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // void *()(void *, void *)
/* 171 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 172 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 173 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 174 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // void *()(wchar_t const *)
/* 175 */ _CFFI_OP(_CFFI_OP_POINTER, 351), // wchar_t const *
/* 176 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 177 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(PyObject *, void *)
/* 178 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 179 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 180 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 181 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_array *)
/* 182 */ _CFFI_OP(_CFFI_OP_NOOP, 99),
/* 183 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 184 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_array *, godot_variant const *)
/* 185 */ _CFFI_OP(_CFFI_OP_NOOP, 99),
/* 186 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 187 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 188 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_array *, int)
/* 189 */ _CFFI_OP(_CFFI_OP_NOOP, 99),
/* 190 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 191 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 192 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_array *, int, godot_variant const *)
/* 193 */ _CFFI_OP(_CFFI_OP_NOOP, 99),
/* 194 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 195 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 196 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 197 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_array *, void *, godot_string const *)
/* 198 */ _CFFI_OP(_CFFI_OP_NOOP, 99),
/* 199 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 200 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 201 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 202 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_dictionary *)
/* 203 */ _CFFI_OP(_CFFI_OP_NOOP, 103),
/* 204 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 205 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_dictionary *, godot_variant const *)
/* 206 */ _CFFI_OP(_CFFI_OP_NOOP, 103),
/* 207 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 208 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 209 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_method_bind *, void *, void const * *, void *)
/* 210 */ _CFFI_OP(_CFFI_OP_POINTER, 329), // godot_method_bind *
/* 211 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 212 */ _CFFI_OP(_CFFI_OP_POINTER, 346), // void const * *
/* 213 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 214 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 215 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_pool_string_array *)
/* 216 */ _CFFI_OP(_CFFI_OP_NOOP, 87),
/* 217 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 218 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_pool_string_array *, godot_array const *)
/* 219 */ _CFFI_OP(_CFFI_OP_NOOP, 87),
/* 220 */ _CFFI_OP(_CFFI_OP_NOOP, 18),
/* 221 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 222 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_pool_string_array *, godot_pool_string_array const *)
/* 223 */ _CFFI_OP(_CFFI_OP_NOOP, 87),
/* 224 */ _CFFI_OP(_CFFI_OP_POINTER, 330), // godot_pool_string_array const *
/* 225 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 226 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_pool_string_array *, godot_string const *)
/* 227 */ _CFFI_OP(_CFFI_OP_NOOP, 87),
/* 228 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 229 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 230 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_pool_string_array *, int)
/* 231 */ _CFFI_OP(_CFFI_OP_NOOP, 87),
/* 232 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 233 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 234 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_pool_string_array *, int, godot_string const *)
/* 235 */ _CFFI_OP(_CFFI_OP_NOOP, 87),
/* 236 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 237 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 238 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 239 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_string *)
/* 240 */ _CFFI_OP(_CFFI_OP_POINTER, 331), // godot_string *
/* 241 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 242 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_string *, char const *, int)
/* 243 */ _CFFI_OP(_CFFI_OP_NOOP, 240),
/* 244 */ _CFFI_OP(_CFFI_OP_NOOP, 80),
/* 245 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 246 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 247 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_string *, godot_string const *, godot_string const *)
/* 248 */ _CFFI_OP(_CFFI_OP_NOOP, 240),
/* 249 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 250 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 251 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 252 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_string const *, godot_string const *)
/* 253 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 254 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 255 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 256 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_string const *, wchar_t *, int *)
/* 257 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 258 */ _CFFI_OP(_CFFI_OP_NOOP, 15),
/* 259 */ _CFFI_OP(_CFFI_OP_POINTER, 9), // int *
/* 260 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 261 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_variant *)
/* 262 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 263 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 264 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_variant *, _Bool)
/* 265 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 266 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 1), // _Bool
/* 267 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 268 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_variant *, double)
/* 269 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 270 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14), // double
/* 271 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 272 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_variant *, godot_string const *)
/* 273 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 274 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 275 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 276 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_variant *, godot_variant const *)
/* 277 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 278 */ _CFFI_OP(_CFFI_OP_NOOP, 22),
/* 279 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 280 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_variant *, uint64_t)
/* 281 */ _CFFI_OP(_CFFI_OP_NOOP, 40),
/* 282 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24), // uint64_t
/* 283 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 284 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_vector2 *)
/* 285 */ _CFFI_OP(_CFFI_OP_POINTER, 334), // godot_vector2 *
/* 286 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 287 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_vector2 *, float)
/* 288 */ _CFFI_OP(_CFFI_OP_NOOP, 285),
/* 289 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 13), // float
/* 290 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 291 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_vector2 *, float, float)
/* 292 */ _CFFI_OP(_CFFI_OP_NOOP, 285),
/* 293 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 13),
/* 294 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 13),
/* 295 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 296 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(godot_vector2 *, godot_vector2 const *)
/* 297 */ _CFFI_OP(_CFFI_OP_NOOP, 285),
/* 298 */ _CFFI_OP(_CFFI_OP_NOOP, 64),
/* 299 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 300 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(void *)
/* 301 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 302 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 303 */ _CFFI_OP(_CFFI_OP_FUNCTION, 350), // void()(void *, wchar_t const *, void * *, int, void *, int *)
/* 304 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 305 */ _CFFI_OP(_CFFI_OP_NOOP, 175),
/* 306 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
/* 307 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 308 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 309 */ _CFFI_OP(_CFFI_OP_NOOP, 259),
/* 310 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 311 */ _CFFI_OP(_CFFI_OP_FUNCTION, 15), // wchar_t *()(godot_string *, int)
/* 312 */ _CFFI_OP(_CFFI_OP_NOOP, 240),
/* 313 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 314 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 315 */ _CFFI_OP(_CFFI_OP_FUNCTION, 175), // wchar_t const *()(godot_string const *)
/* 316 */ _CFFI_OP(_CFFI_OP_NOOP, 36),
/* 317 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 318 */ _CFFI_OP(_CFFI_OP_POINTER, 0), // PyObject *(*)(PyObject *)
/* 319 */ _CFFI_OP(_CFFI_OP_POINTER, 3), // PyObject *(*)(PyObject *, void *)
/* 320 */ _CFFI_OP(_CFFI_OP_POINTER, 7), // PyObject *(*)(void * *, int)
/* 321 */ _CFFI_OP(_CFFI_OP_POINTER, 11), // PyObject *(*)(void *)
/* 322 */ _CFFI_OP(_CFFI_OP_POINTER, 14), // PyObject *(*)(wchar_t *)
/* 323 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 0), // PyObject
/* 324 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 2), // char
/* 325 */ _CFFI_OP(_CFFI_OP_ENUM, 0), // enum MethodFlags
/* 326 */ _CFFI_OP(_CFFI_OP_ENUM, 1), // enum godot_variant_type
/* 327 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 1), // godot_array
/* 328 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 2), // godot_dictionary
/* 329 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 3), // godot_method_bind
/* 330 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 4), // godot_pool_string_array
/* 331 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 5), // godot_string
/* 332 */ _CFFI_OP(_CFFI_OP_POINTER, 93), // godot_variant *(*)(PyObject *, godot_variant const * *, int)
/* 333 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 6), // godot_variant
/* 334 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 7), // godot_vector2
/* 335 */ _CFFI_OP(_CFFI_OP_POINTER, 152), // int(*)(int, int)
/* 336 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 22), // uint32_t
/* 337 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 18), // uint8_t
/* 338 */ _CFFI_OP(_CFFI_OP_ARRAY, 337), // uint8_t[1]
/* 339 */ (_cffi_opcode_t)(1),
/* 340 */ _CFFI_OP(_CFFI_OP_ARRAY, 337), // uint8_t[24]
/* 341 */ (_cffi_opcode_t)(24),
/* 342 */ _CFFI_OP(_CFFI_OP_ARRAY, 337), // uint8_t[8]
/* 343 */ (_cffi_opcode_t)(8),
/* 344 */ _CFFI_OP(_CFFI_OP_POINTER, 170), // void *(*)(void *, void *)
/* 345 */ _CFFI_OP(_CFFI_OP_POINTER, 174), // void *(*)(wchar_t const *)
/* 346 */ _CFFI_OP(_CFFI_OP_POINTER, 350), // void const *
/* 347 */ _CFFI_OP(_CFFI_OP_POINTER, 177), // void(*)(PyObject *, void *)
/* 348 */ _CFFI_OP(_CFFI_OP_POINTER, 300), // void(*)(void *)
/* 349 */ _CFFI_OP(_CFFI_OP_POINTER, 303), // void(*)(void *, wchar_t const *, void * *, int, void *, int *)
/* 350 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 0), // void
/* 351 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 16), // wchar_t
};

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_PyObject(PyObject *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
}
struct _cffi_align_typedef_PyObject { char x; PyObject y; };

static struct _cffi_externpy_s _cffi_externpy__call_with_variants =
  { "call_with_variants", (int)sizeof(godot_variant *) };

CFFI_DLLEXPORT godot_variant * call_with_variants(PyObject * a0, godot_variant const * * a1, int a2)
{
  char a[24];
  char *p = a;
  *(PyObject * *)(p + 0) = a0;
  *(godot_variant const * * *)(p + 8) = a1;
  *(int *)(p + 16) = a2;
  _cffi_call_python(&_cffi_externpy__call_with_variants, p);
  return *(godot_variant * *)p;
}

static struct _cffi_externpy_s _cffi_externpy__do_stuff =
  { "do_stuff", (int)sizeof(int) };

CFFI_DLLEXPORT int do_stuff(int a0, int a1)
{
  char a[16];
  char *p = a;
  *(int *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  _cffi_call_python(&_cffi_externpy__do_stuff, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__instanciate_binding_from_godot_obj =
  { "instanciate_binding_from_godot_obj", (int)sizeof(PyObject *) };

CFFI_DLLEXPORT PyObject * instanciate_binding_from_godot_obj(PyObject * a0, void * a1)
{
  char a[16];
  char *p = a;
  *(PyObject * *)(p + 0) = a0;
  *(void * *)(p + 8) = a1;
  _cffi_call_python(&_cffi_externpy__instanciate_binding_from_godot_obj, p);
  return *(PyObject * *)p;
}

static struct _cffi_externpy_s _cffi_externpy__py_instance_set_godot_obj =
  { "py_instance_set_godot_obj", 0 };

CFFI_DLLEXPORT void py_instance_set_godot_obj(PyObject * a0, void * a1)
{
  char a[16];
  char *p = a;
  *(PyObject * *)(p + 0) = a0;
  *(void * *)(p + 8) = a1;
  _cffi_call_python(&_cffi_externpy__py_instance_set_godot_obj, p);
}

static struct _cffi_externpy_s _cffi_externpy__pybind_call_meth =
  { "pybind_call_meth", 0 };

CFFI_DLLEXPORT void pybind_call_meth(void * a0, wchar_t const * a1, void * * a2, int a3, void * a4, int * a5)
{
  char a[48];
  char *p = a;
  *(void * *)(p + 0) = a0;
  *(wchar_t const * *)(p + 8) = a1;
  *(void * * *)(p + 16) = a2;
  *(int *)(p + 24) = a3;
  *(void * *)(p + 32) = a4;
  *(int * *)(p + 40) = a5;
  _cffi_call_python(&_cffi_externpy__pybind_call_meth, p);
}

static struct _cffi_externpy_s _cffi_externpy__pybind_instanciate_from_classname =
  { "pybind_instanciate_from_classname", (int)sizeof(void *) };

CFFI_DLLEXPORT void * pybind_instanciate_from_classname(wchar_t const * a0)
{
  char a[8];
  char *p = a;
  *(wchar_t const * *)(p + 0) = a0;
  _cffi_call_python(&_cffi_externpy__pybind_instanciate_from_classname, p);
  return *(void * *)p;
}

static struct _cffi_externpy_s _cffi_externpy__pybind_load_exposed_class_per_module =
  { "pybind_load_exposed_class_per_module", (int)sizeof(void *) };

CFFI_DLLEXPORT void * pybind_load_exposed_class_per_module(wchar_t const * a0)
{
  char a[8];
  char *p = a;
  *(wchar_t const * *)(p + 0) = a0;
  _cffi_call_python(&_cffi_externpy__pybind_load_exposed_class_per_module, p);
  return *(void * *)p;
}

static struct _cffi_externpy_s _cffi_externpy__pybind_module_from_name =
  { "pybind_module_from_name", (int)sizeof(PyObject *) };

CFFI_DLLEXPORT PyObject * pybind_module_from_name(wchar_t * a0)
{
  char a[8];
  char *p = a;
  *(wchar_t * *)(p + 0) = a0;
  _cffi_call_python(&_cffi_externpy__pybind_module_from_name, p);
  return *(PyObject * *)p;
}

static struct _cffi_externpy_s _cffi_externpy__pybind_release_instance =
  { "pybind_release_instance", 0 };

CFFI_DLLEXPORT void pybind_release_instance(void * a0)
{
  char a[8];
  char *p = a;
  *(void * *)(p + 0) = a0;
  _cffi_call_python(&_cffi_externpy__pybind_release_instance, p);
}

static struct _cffi_externpy_s _cffi_externpy__pybind_wrap_gdobj_with_class =
  { "pybind_wrap_gdobj_with_class", (int)sizeof(void *) };

CFFI_DLLEXPORT void * pybind_wrap_gdobj_with_class(void * a0, void * a1)
{
  char a[16];
  char *p = a;
  *(void * *)(p + 0) = a0;
  *(void * *)(p + 8) = a1;
  _cffi_call_python(&_cffi_externpy__pybind_wrap_gdobj_with_class, p);
  return *(void * *)p;
}

static struct _cffi_externpy_s _cffi_externpy__pyobj_to_variant2 =
  { "pyobj_to_variant2", (int)sizeof(PyObject *) };

CFFI_DLLEXPORT PyObject * pyobj_to_variant2(PyObject * a0)
{
  char a[8];
  char *p = a;
  *(PyObject * *)(p + 0) = a0;
  _cffi_call_python(&_cffi_externpy__pyobj_to_variant2, p);
  return *(PyObject * *)p;
}

static struct _cffi_externpy_s _cffi_externpy__variant_to_pyobj2 =
  { "variant_to_pyobj2", (int)sizeof(PyObject *) };

CFFI_DLLEXPORT PyObject * variant_to_pyobj2(void * a0)
{
  char a[8];
  char *p = a;
  *(void * *)(p + 0) = a0;
  _cffi_call_python(&_cffi_externpy__variant_to_pyobj2, p);
  return *(PyObject * *)p;
}

static struct _cffi_externpy_s _cffi_externpy__variants_to_pyobjs =
  { "variants_to_pyobjs", (int)sizeof(PyObject *) };

CFFI_DLLEXPORT PyObject * variants_to_pyobjs(void * * a0, int a1)
{
  char a[16];
  char *p = a;
  *(void * * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  _cffi_call_python(&_cffi_externpy__variants_to_pyobjs, p);
  return *(PyObject * *)p;
}

static int _cffi_const_METHOD_FLAG_NORMAL(unsigned long long *o)
{
  int n = (METHOD_FLAG_NORMAL) <= 0;
  *o = (unsigned long long)((METHOD_FLAG_NORMAL) | 0);  /* check that METHOD_FLAG_NORMAL is an integer */
  return n;
}

static int _cffi_const_METHOD_FLAG_EDITOR(unsigned long long *o)
{
  int n = (METHOD_FLAG_EDITOR) <= 0;
  *o = (unsigned long long)((METHOD_FLAG_EDITOR) | 0);  /* check that METHOD_FLAG_EDITOR is an integer */
  return n;
}

static int _cffi_const_METHOD_FLAG_NOSCRIPT(unsigned long long *o)
{
  int n = (METHOD_FLAG_NOSCRIPT) <= 0;
  *o = (unsigned long long)((METHOD_FLAG_NOSCRIPT) | 0);  /* check that METHOD_FLAG_NOSCRIPT is an integer */
  return n;
}

static int _cffi_const_METHOD_FLAG_CONST(unsigned long long *o)
{
  int n = (METHOD_FLAG_CONST) <= 0;
  *o = (unsigned long long)((METHOD_FLAG_CONST) | 0);  /* check that METHOD_FLAG_CONST is an integer */
  return n;
}

static int _cffi_const_METHOD_FLAG_REVERSE(unsigned long long *o)
{
  int n = (METHOD_FLAG_REVERSE) <= 0;
  *o = (unsigned long long)((METHOD_FLAG_REVERSE) | 0);  /* check that METHOD_FLAG_REVERSE is an integer */
  return n;
}

static int _cffi_const_METHOD_FLAG_VIRTUAL(unsigned long long *o)
{
  int n = (METHOD_FLAG_VIRTUAL) <= 0;
  *o = (unsigned long long)((METHOD_FLAG_VIRTUAL) | 0);  /* check that METHOD_FLAG_VIRTUAL is an integer */
  return n;
}

static int _cffi_const_METHOD_FLAG_FROM_SCRIPT(unsigned long long *o)
{
  int n = (METHOD_FLAG_FROM_SCRIPT) <= 0;
  *o = (unsigned long long)((METHOD_FLAG_FROM_SCRIPT) | 0);  /* check that METHOD_FLAG_FROM_SCRIPT is an integer */
  return n;
}

static int _cffi_const_METHOD_FLAG_VARARG(unsigned long long *o)
{
  int n = (METHOD_FLAG_VARARG) <= 0;
  *o = (unsigned long long)((METHOD_FLAG_VARARG) | 0);  /* check that METHOD_FLAG_VARARG is an integer */
  return n;
}

static int _cffi_const_METHOD_FLAGS_DEFAULT(unsigned long long *o)
{
  int n = (METHOD_FLAGS_DEFAULT) <= 0;
  *o = (unsigned long long)((METHOD_FLAGS_DEFAULT) | 0);  /* check that METHOD_FLAGS_DEFAULT is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_NIL(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_NIL) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_NIL) | 0);  /* check that GODOT_VARIANT_TYPE_NIL is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_BOOL(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_BOOL) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_BOOL) | 0);  /* check that GODOT_VARIANT_TYPE_BOOL is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_INT(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_INT) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_INT) | 0);  /* check that GODOT_VARIANT_TYPE_INT is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_REAL(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_REAL) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_REAL) | 0);  /* check that GODOT_VARIANT_TYPE_REAL is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_STRING(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_STRING) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_STRING) | 0);  /* check that GODOT_VARIANT_TYPE_STRING is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_VECTOR2(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_VECTOR2) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_VECTOR2) | 0);  /* check that GODOT_VARIANT_TYPE_VECTOR2 is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_RECT2(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_RECT2) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_RECT2) | 0);  /* check that GODOT_VARIANT_TYPE_RECT2 is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_VECTOR3(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_VECTOR3) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_VECTOR3) | 0);  /* check that GODOT_VARIANT_TYPE_VECTOR3 is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_TRANSFORM2D(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_TRANSFORM2D) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_TRANSFORM2D) | 0);  /* check that GODOT_VARIANT_TYPE_TRANSFORM2D is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_PLANE(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_PLANE) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_PLANE) | 0);  /* check that GODOT_VARIANT_TYPE_PLANE is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_QUAT(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_QUAT) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_QUAT) | 0);  /* check that GODOT_VARIANT_TYPE_QUAT is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_RECT3(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_RECT3) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_RECT3) | 0);  /* check that GODOT_VARIANT_TYPE_RECT3 is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_BASIS(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_BASIS) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_BASIS) | 0);  /* check that GODOT_VARIANT_TYPE_BASIS is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_TRANSFORM(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_TRANSFORM) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_TRANSFORM) | 0);  /* check that GODOT_VARIANT_TYPE_TRANSFORM is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_COLOR(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_COLOR) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_COLOR) | 0);  /* check that GODOT_VARIANT_TYPE_COLOR is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_IMAGE(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_IMAGE) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_IMAGE) | 0);  /* check that GODOT_VARIANT_TYPE_IMAGE is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_NODE_PATH(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_NODE_PATH) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_NODE_PATH) | 0);  /* check that GODOT_VARIANT_TYPE_NODE_PATH is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_RID(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_RID) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_RID) | 0);  /* check that GODOT_VARIANT_TYPE_RID is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_OBJECT(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_OBJECT) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_OBJECT) | 0);  /* check that GODOT_VARIANT_TYPE_OBJECT is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_INPUT_EVENT(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_INPUT_EVENT) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_INPUT_EVENT) | 0);  /* check that GODOT_VARIANT_TYPE_INPUT_EVENT is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_DICTIONARY(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_DICTIONARY) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_DICTIONARY) | 0);  /* check that GODOT_VARIANT_TYPE_DICTIONARY is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_ARRAY(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_ARRAY) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_ARRAY) | 0);  /* check that GODOT_VARIANT_TYPE_ARRAY is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY) | 0);  /* check that GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_POOL_INT_ARRAY(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_POOL_INT_ARRAY) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_POOL_INT_ARRAY) | 0);  /* check that GODOT_VARIANT_TYPE_POOL_INT_ARRAY is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_POOL_REAL_ARRAY(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_POOL_REAL_ARRAY) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_POOL_REAL_ARRAY) | 0);  /* check that GODOT_VARIANT_TYPE_POOL_REAL_ARRAY is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_POOL_STRING_ARRAY(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_POOL_STRING_ARRAY) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_POOL_STRING_ARRAY) | 0);  /* check that GODOT_VARIANT_TYPE_POOL_STRING_ARRAY is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY) | 0);  /* check that GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY) | 0);  /* check that GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY is an integer */
  return n;
}

static int _cffi_const_GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY(unsigned long long *o)
{
  int n = (GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY) <= 0;
  *o = (unsigned long long)((GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY) | 0);  /* check that GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY is an integer */
  return n;
}

static void _cffi_d_godot_array_append(godot_array * x0, godot_variant const * x1)
{
  godot_array_append(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_append(PyObject *self, PyObject *args)
{
  godot_array * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_array_append", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_append(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_append _cffi_d_godot_array_append
#endif

static godot_variant _cffi_d_godot_array_back(godot_array const * x0)
{
  return godot_array_back(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_back(PyObject *self, PyObject *arg0)
{
  godot_array const * x0;
  Py_ssize_t datasize;
  godot_variant result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(18), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_back(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(333));
}
#else
static void _cffi_f_godot_array_back(godot_variant *result, godot_array const * x0)
{
  { *result = godot_array_back(x0); }
}
#endif

static void _cffi_d_godot_array_clear(godot_array * x0)
{
  godot_array_clear(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_clear(PyObject *self, PyObject *arg0)
{
  godot_array * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_clear(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_clear _cffi_d_godot_array_clear
#endif

static int _cffi_d_godot_array_count(godot_array * x0, godot_variant const * x1)
{
  return godot_array_count(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_count(PyObject *self, PyObject *args)
{
  godot_array * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_array_count", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_count(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_godot_array_count _cffi_d_godot_array_count
#endif

static void _cffi_d_godot_array_destroy(godot_array * x0)
{
  godot_array_destroy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_destroy(PyObject *self, PyObject *arg0)
{
  godot_array * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_destroy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_destroy _cffi_d_godot_array_destroy
#endif

static _Bool _cffi_d_godot_array_empty(godot_array const * x0)
{
  return godot_array_empty(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_empty(PyObject *self, PyObject *arg0)
{
  godot_array const * x0;
  Py_ssize_t datasize;
  _Bool result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(18), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_empty(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_array_empty _cffi_d_godot_array_empty
#endif

static void _cffi_d_godot_array_erase(godot_array * x0, godot_variant const * x1)
{
  godot_array_erase(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_erase(PyObject *self, PyObject *args)
{
  godot_array * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_array_erase", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_erase(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_erase _cffi_d_godot_array_erase
#endif

static int _cffi_d_godot_array_find(godot_array const * x0, godot_variant const * x1, int x2)
{
  return godot_array_find(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_find(PyObject *self, PyObject *args)
{
  godot_array const * x0;
  godot_variant const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "godot_array_find", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(18), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_find(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_godot_array_find _cffi_d_godot_array_find
#endif

static int _cffi_d_godot_array_find_last(godot_array const * x0, godot_variant const * x1)
{
  return godot_array_find_last(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_find_last(PyObject *self, PyObject *args)
{
  godot_array const * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_array_find_last", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(18), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_find_last(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_godot_array_find_last _cffi_d_godot_array_find_last
#endif

static godot_variant _cffi_d_godot_array_front(godot_array const * x0)
{
  return godot_array_front(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_front(PyObject *self, PyObject *arg0)
{
  godot_array const * x0;
  Py_ssize_t datasize;
  godot_variant result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(18), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_front(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(333));
}
#else
static void _cffi_f_godot_array_front(godot_variant *result, godot_array const * x0)
{
  { *result = godot_array_front(x0); }
}
#endif

static godot_variant * _cffi_d_godot_array_get(godot_array * x0, int x1)
{
  return godot_array_get(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_get(PyObject *self, PyObject *args)
{
  godot_array * x0;
  int x1;
  Py_ssize_t datasize;
  godot_variant * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_array_get", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_get(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(40));
}
#else
#  define _cffi_f_godot_array_get _cffi_d_godot_array_get
#endif

static _Bool _cffi_d_godot_array_has(godot_array const * x0, godot_variant const * x1)
{
  return godot_array_has(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_has(PyObject *self, PyObject *args)
{
  godot_array const * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  _Bool result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_array_has", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(18), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_has(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_array_has _cffi_d_godot_array_has
#endif

static uint32_t _cffi_d_godot_array_hash(godot_array const * x0)
{
  return godot_array_hash(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_hash(PyObject *self, PyObject *arg0)
{
  godot_array const * x0;
  Py_ssize_t datasize;
  uint32_t result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(18), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_hash(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, uint32_t);
}
#else
#  define _cffi_f_godot_array_hash _cffi_d_godot_array_hash
#endif

static void _cffi_d_godot_array_insert(godot_array * x0, int x1, godot_variant const * x2)
{
  godot_array_insert(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_insert(PyObject *self, PyObject *args)
{
  godot_array * x0;
  int x1;
  godot_variant const * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "godot_array_insert", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(22), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_insert(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_insert _cffi_d_godot_array_insert
#endif

static void _cffi_d_godot_array_invert(godot_array * x0)
{
  godot_array_invert(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_invert(PyObject *self, PyObject *arg0)
{
  godot_array * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_invert(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_invert _cffi_d_godot_array_invert
#endif

static _Bool _cffi_d_godot_array_is_shared(godot_array const * x0)
{
  return godot_array_is_shared(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_is_shared(PyObject *self, PyObject *arg0)
{
  godot_array const * x0;
  Py_ssize_t datasize;
  _Bool result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(18), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_is_shared(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_array_is_shared _cffi_d_godot_array_is_shared
#endif

static godot_variant _cffi_d_godot_array_pop_back(godot_array * x0)
{
  return godot_array_pop_back(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_pop_back(PyObject *self, PyObject *arg0)
{
  godot_array * x0;
  Py_ssize_t datasize;
  godot_variant result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_pop_back(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(333));
}
#else
static void _cffi_f_godot_array_pop_back(godot_variant *result, godot_array * x0)
{
  { *result = godot_array_pop_back(x0); }
}
#endif

static godot_variant _cffi_d_godot_array_pop_front(godot_array * x0)
{
  return godot_array_pop_front(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_pop_front(PyObject *self, PyObject *arg0)
{
  godot_array * x0;
  Py_ssize_t datasize;
  godot_variant result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_pop_front(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(333));
}
#else
static void _cffi_f_godot_array_pop_front(godot_variant *result, godot_array * x0)
{
  { *result = godot_array_pop_front(x0); }
}
#endif

static void _cffi_d_godot_array_push_back(godot_array * x0, godot_variant const * x1)
{
  godot_array_push_back(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_push_back(PyObject *self, PyObject *args)
{
  godot_array * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_array_push_back", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_push_back(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_push_back _cffi_d_godot_array_push_back
#endif

static void _cffi_d_godot_array_push_front(godot_array * x0, godot_variant const * x1)
{
  godot_array_push_front(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_push_front(PyObject *self, PyObject *args)
{
  godot_array * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_array_push_front", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_push_front(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_push_front _cffi_d_godot_array_push_front
#endif

static void _cffi_d_godot_array_remove(godot_array * x0, int x1)
{
  godot_array_remove(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_remove(PyObject *self, PyObject *args)
{
  godot_array * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_array_remove", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_remove(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_remove _cffi_d_godot_array_remove
#endif

static void _cffi_d_godot_array_resize(godot_array * x0, int x1)
{
  godot_array_resize(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_resize(PyObject *self, PyObject *args)
{
  godot_array * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_array_resize", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_resize(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_resize _cffi_d_godot_array_resize
#endif

static int _cffi_d_godot_array_rfind(godot_array const * x0, godot_variant const * x1, int x2)
{
  return godot_array_rfind(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_rfind(PyObject *self, PyObject *args)
{
  godot_array const * x0;
  godot_variant const * x1;
  int x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "godot_array_rfind", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(18), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_rfind(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_godot_array_rfind _cffi_d_godot_array_rfind
#endif

static void _cffi_d_godot_array_set(godot_array * x0, int x1, godot_variant const * x2)
{
  godot_array_set(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_set(PyObject *self, PyObject *args)
{
  godot_array * x0;
  int x1;
  godot_variant const * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "godot_array_set", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(22), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_set(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_set _cffi_d_godot_array_set
#endif

static int _cffi_d_godot_array_size(godot_array const * x0)
{
  return godot_array_size(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_size(PyObject *self, PyObject *arg0)
{
  godot_array const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(18), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_array_size(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_godot_array_size _cffi_d_godot_array_size
#endif

static void _cffi_d_godot_array_sort(godot_array * x0)
{
  godot_array_sort(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_sort(PyObject *self, PyObject *arg0)
{
  godot_array * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_sort(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_sort _cffi_d_godot_array_sort
#endif

static void _cffi_d_godot_array_sort_custom(godot_array * x0, void * x1, godot_string const * x2)
{
  godot_array_sort_custom(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_array_sort_custom(PyObject *self, PyObject *args)
{
  godot_array * x0;
  void * x1;
  godot_string const * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "godot_array_sort_custom", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(99), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(99), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(5), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(36), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_array_sort_custom(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_array_sort_custom _cffi_d_godot_array_sort_custom
#endif

static void _cffi_d_godot_dictionary_clear(godot_dictionary * x0)
{
  godot_dictionary_clear(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_clear(PyObject *self, PyObject *arg0)
{
  godot_dictionary * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(103), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(103), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_dictionary_clear(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_dictionary_clear _cffi_d_godot_dictionary_clear
#endif

static void _cffi_d_godot_dictionary_destroy(godot_dictionary * x0)
{
  godot_dictionary_destroy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_destroy(PyObject *self, PyObject *arg0)
{
  godot_dictionary * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(103), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(103), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_dictionary_destroy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_dictionary_destroy _cffi_d_godot_dictionary_destroy
#endif

static _Bool _cffi_d_godot_dictionary_empty(godot_dictionary const * x0)
{
  return godot_dictionary_empty(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_empty(PyObject *self, PyObject *arg0)
{
  godot_dictionary const * x0;
  Py_ssize_t datasize;
  _Bool result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(25), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(25), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_dictionary_empty(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_dictionary_empty _cffi_d_godot_dictionary_empty
#endif

static void _cffi_d_godot_dictionary_erase(godot_dictionary * x0, godot_variant const * x1)
{
  godot_dictionary_erase(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_erase(PyObject *self, PyObject *args)
{
  godot_dictionary * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_dictionary_erase", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(103), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(103), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_dictionary_erase(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_dictionary_erase _cffi_d_godot_dictionary_erase
#endif

static _Bool _cffi_d_godot_dictionary_has(godot_dictionary const * x0, godot_variant const * x1)
{
  return godot_dictionary_has(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_has(PyObject *self, PyObject *args)
{
  godot_dictionary const * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  _Bool result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_dictionary_has", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(25), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(25), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_dictionary_has(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_dictionary_has _cffi_d_godot_dictionary_has
#endif

static _Bool _cffi_d_godot_dictionary_has_all(godot_dictionary const * x0, godot_array const * x1)
{
  return godot_dictionary_has_all(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_has_all(PyObject *self, PyObject *args)
{
  godot_dictionary const * x0;
  godot_array const * x1;
  Py_ssize_t datasize;
  _Bool result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_dictionary_has_all", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(25), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(25), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_array const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(18), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_dictionary_has_all(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_dictionary_has_all _cffi_d_godot_dictionary_has_all
#endif

static uint32_t _cffi_d_godot_dictionary_hash(godot_dictionary const * x0)
{
  return godot_dictionary_hash(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_hash(PyObject *self, PyObject *arg0)
{
  godot_dictionary const * x0;
  Py_ssize_t datasize;
  uint32_t result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(25), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(25), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_dictionary_hash(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, uint32_t);
}
#else
#  define _cffi_f_godot_dictionary_hash _cffi_d_godot_dictionary_hash
#endif

static godot_array _cffi_d_godot_dictionary_keys(godot_dictionary const * x0)
{
  return godot_dictionary_keys(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_keys(PyObject *self, PyObject *arg0)
{
  godot_dictionary const * x0;
  Py_ssize_t datasize;
  godot_array result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(25), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(25), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_dictionary_keys(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(327));
}
#else
static void _cffi_f_godot_dictionary_keys(godot_array *result, godot_dictionary const * x0)
{
  { *result = godot_dictionary_keys(x0); }
}
#endif

static void _cffi_d_godot_dictionary_new(godot_dictionary * x0)
{
  godot_dictionary_new(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_new(PyObject *self, PyObject *arg0)
{
  godot_dictionary * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(103), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(103), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_dictionary_new(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_dictionary_new _cffi_d_godot_dictionary_new
#endif

static godot_variant * _cffi_d_godot_dictionary_operator_index(godot_dictionary * x0, godot_variant const * x1)
{
  return godot_dictionary_operator_index(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_operator_index(PyObject *self, PyObject *args)
{
  godot_dictionary * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  godot_variant * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_dictionary_operator_index", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(103), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(103), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_dictionary_operator_index(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(40));
}
#else
#  define _cffi_f_godot_dictionary_operator_index _cffi_d_godot_dictionary_operator_index
#endif

static int _cffi_d_godot_dictionary_parse_json(godot_dictionary * x0, godot_string const * x1)
{
  return godot_dictionary_parse_json(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_parse_json(PyObject *self, PyObject *args)
{
  godot_dictionary * x0;
  godot_string const * x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_dictionary_parse_json", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(103), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(103), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(36), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_dictionary_parse_json(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_godot_dictionary_parse_json _cffi_d_godot_dictionary_parse_json
#endif

static int _cffi_d_godot_dictionary_size(godot_dictionary const * x0)
{
  return godot_dictionary_size(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_size(PyObject *self, PyObject *arg0)
{
  godot_dictionary const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(25), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(25), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_dictionary_size(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_godot_dictionary_size _cffi_d_godot_dictionary_size
#endif

static godot_string _cffi_d_godot_dictionary_to_json(godot_dictionary const * x0)
{
  return godot_dictionary_to_json(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_to_json(PyObject *self, PyObject *arg0)
{
  godot_dictionary const * x0;
  Py_ssize_t datasize;
  godot_string result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(25), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(25), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_dictionary_to_json(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(331));
}
#else
static void _cffi_f_godot_dictionary_to_json(godot_string *result, godot_dictionary const * x0)
{
  { *result = godot_dictionary_to_json(x0); }
}
#endif

static godot_array _cffi_d_godot_dictionary_values(godot_dictionary const * x0)
{
  return godot_dictionary_values(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_dictionary_values(PyObject *self, PyObject *arg0)
{
  godot_dictionary const * x0;
  Py_ssize_t datasize;
  godot_array result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(25), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_dictionary const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(25), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_dictionary_values(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(327));
}
#else
static void _cffi_f_godot_dictionary_values(godot_array *result, godot_dictionary const * x0)
{
  { *result = godot_dictionary_values(x0); }
}
#endif

static int _cffi_d_godot_get_global_constant_count(void)
{
  return godot_get_global_constant_count();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_get_global_constant_count(PyObject *self, PyObject *noarg)
{
  int result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_get_global_constant_count(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_godot_get_global_constant_count _cffi_d_godot_get_global_constant_count
#endif

static char const * _cffi_d_godot_get_global_constant_name(int x0)
{
  return godot_get_global_constant_name(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_get_global_constant_name(PyObject *self, PyObject *arg0)
{
  int x0;
  char const * result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_get_global_constant_name(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(80));
}
#else
#  define _cffi_f_godot_get_global_constant_name _cffi_d_godot_get_global_constant_name
#endif

static int _cffi_d_godot_get_global_constant_value(int x0)
{
  return godot_get_global_constant_value(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_get_global_constant_value(PyObject *self, PyObject *arg0)
{
  int x0;
  int result;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_get_global_constant_value(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_godot_get_global_constant_value _cffi_d_godot_get_global_constant_value
#endif

static void * _cffi_d_godot_global_get_singleton(char * x0)
{
  return godot_global_get_singleton(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_global_get_singleton(PyObject *self, PyObject *arg0)
{
  char * x0;
  Py_ssize_t datasize;
  void * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(168), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(168), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_global_get_singleton(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(5));
}
#else
#  define _cffi_f_godot_global_get_singleton _cffi_d_godot_global_get_singleton
#endif

static godot_method_bind * _cffi_d_godot_method_bind_get_method(char const * x0, char const * x1)
{
  return godot_method_bind_get_method(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_method_bind_get_method(PyObject *self, PyObject *args)
{
  char const * x0;
  char const * x1;
  Py_ssize_t datasize;
  godot_method_bind * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_method_bind_get_method", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(80), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(80), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_method_bind_get_method(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(210));
}
#else
#  define _cffi_f_godot_method_bind_get_method _cffi_d_godot_method_bind_get_method
#endif

static void _cffi_d_godot_method_bind_ptrcall(godot_method_bind * x0, void * x1, void const * * x2, void * x3)
{
  godot_method_bind_ptrcall(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_method_bind_ptrcall(PyObject *self, PyObject *args)
{
  godot_method_bind * x0;
  void * x1;
  void const * * x2;
  void * x3;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "godot_method_bind_ptrcall", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(210), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_method_bind *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(210), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(5), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(212), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (void const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(212), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(5), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_method_bind_ptrcall(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_method_bind_ptrcall _cffi_d_godot_method_bind_ptrcall
#endif

static void _cffi_d_godot_pool_string_array_append(godot_pool_string_array * x0, godot_string const * x1)
{
  godot_pool_string_array_append(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_append(PyObject *self, PyObject *args)
{
  godot_pool_string_array * x0;
  godot_string const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_pool_string_array_append", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(36), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_pool_string_array_append(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_pool_string_array_append _cffi_d_godot_pool_string_array_append
#endif

static void _cffi_d_godot_pool_string_array_append_array(godot_pool_string_array * x0, godot_pool_string_array const * x1)
{
  godot_pool_string_array_append_array(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_append_array(PyObject *self, PyObject *args)
{
  godot_pool_string_array * x0;
  godot_pool_string_array const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_pool_string_array_append_array", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(224), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_pool_string_array const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(224), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_pool_string_array_append_array(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_pool_string_array_append_array _cffi_d_godot_pool_string_array_append_array
#endif

static void _cffi_d_godot_pool_string_array_destroy(godot_pool_string_array * x0)
{
  godot_pool_string_array_destroy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_destroy(PyObject *self, PyObject *arg0)
{
  godot_pool_string_array * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_pool_string_array_destroy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_pool_string_array_destroy _cffi_d_godot_pool_string_array_destroy
#endif

static godot_string _cffi_d_godot_pool_string_array_get(godot_pool_string_array * x0, int x1)
{
  return godot_pool_string_array_get(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_get(PyObject *self, PyObject *args)
{
  godot_pool_string_array * x0;
  int x1;
  Py_ssize_t datasize;
  godot_string result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_pool_string_array_get", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_pool_string_array_get(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(331));
}
#else
static void _cffi_f_godot_pool_string_array_get(godot_string *result, godot_pool_string_array * x0, int x1)
{
  { *result = godot_pool_string_array_get(x0, x1); }
}
#endif

static int _cffi_d_godot_pool_string_array_insert(godot_pool_string_array * x0, int x1, godot_string const * x2)
{
  return godot_pool_string_array_insert(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_insert(PyObject *self, PyObject *args)
{
  godot_pool_string_array * x0;
  int x1;
  godot_string const * x2;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "godot_pool_string_array_insert", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(36), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_pool_string_array_insert(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_godot_pool_string_array_insert _cffi_d_godot_pool_string_array_insert
#endif

static void _cffi_d_godot_pool_string_array_invert(godot_pool_string_array * x0)
{
  godot_pool_string_array_invert(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_invert(PyObject *self, PyObject *arg0)
{
  godot_pool_string_array * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_pool_string_array_invert(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_pool_string_array_invert _cffi_d_godot_pool_string_array_invert
#endif

static void _cffi_d_godot_pool_string_array_new(godot_pool_string_array * x0)
{
  godot_pool_string_array_new(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_new(PyObject *self, PyObject *arg0)
{
  godot_pool_string_array * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_pool_string_array_new(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_pool_string_array_new _cffi_d_godot_pool_string_array_new
#endif

static void _cffi_d_godot_pool_string_array_new_with_array(godot_pool_string_array * x0, godot_array const * x1)
{
  godot_pool_string_array_new_with_array(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_new_with_array(PyObject *self, PyObject *args)
{
  godot_pool_string_array * x0;
  godot_array const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_pool_string_array_new_with_array", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_array const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(18), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_pool_string_array_new_with_array(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_pool_string_array_new_with_array _cffi_d_godot_pool_string_array_new_with_array
#endif

static void _cffi_d_godot_pool_string_array_push_back(godot_pool_string_array * x0, godot_string const * x1)
{
  godot_pool_string_array_push_back(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_push_back(PyObject *self, PyObject *args)
{
  godot_pool_string_array * x0;
  godot_string const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_pool_string_array_push_back", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(36), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_pool_string_array_push_back(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_pool_string_array_push_back _cffi_d_godot_pool_string_array_push_back
#endif

static void _cffi_d_godot_pool_string_array_remove(godot_pool_string_array * x0, int x1)
{
  godot_pool_string_array_remove(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_remove(PyObject *self, PyObject *args)
{
  godot_pool_string_array * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_pool_string_array_remove", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_pool_string_array_remove(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_pool_string_array_remove _cffi_d_godot_pool_string_array_remove
#endif

static void _cffi_d_godot_pool_string_array_resize(godot_pool_string_array * x0, int x1)
{
  godot_pool_string_array_resize(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_resize(PyObject *self, PyObject *args)
{
  godot_pool_string_array * x0;
  int x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_pool_string_array_resize", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_pool_string_array_resize(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_pool_string_array_resize _cffi_d_godot_pool_string_array_resize
#endif

static void _cffi_d_godot_pool_string_array_set(godot_pool_string_array * x0, int x1, godot_string const * x2)
{
  godot_pool_string_array_set(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_set(PyObject *self, PyObject *args)
{
  godot_pool_string_array * x0;
  int x1;
  godot_string const * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "godot_pool_string_array_set", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(36), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_pool_string_array_set(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_pool_string_array_set _cffi_d_godot_pool_string_array_set
#endif

static int _cffi_d_godot_pool_string_array_size(godot_pool_string_array * x0)
{
  return godot_pool_string_array_size(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_pool_string_array_size(PyObject *self, PyObject *arg0)
{
  godot_pool_string_array * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_pool_string_array *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(87), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_pool_string_array_size(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_godot_pool_string_array_size _cffi_d_godot_pool_string_array_size
#endif

static wchar_t const * _cffi_d_godot_string_c_str(godot_string const * x0)
{
  return godot_string_c_str(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_string_c_str(PyObject *self, PyObject *arg0)
{
  godot_string const * x0;
  Py_ssize_t datasize;
  wchar_t const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(36), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_string_c_str(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(175));
}
#else
#  define _cffi_f_godot_string_c_str _cffi_d_godot_string_c_str
#endif

static void _cffi_d_godot_string_copy_string(godot_string const * x0, godot_string const * x1)
{
  godot_string_copy_string(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_string_copy_string(PyObject *self, PyObject *args)
{
  godot_string const * x0;
  godot_string const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_string_copy_string", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(36), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(36), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_string_copy_string(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_string_copy_string _cffi_d_godot_string_copy_string
#endif

static void _cffi_d_godot_string_get_data(godot_string const * x0, wchar_t * x1, int * x2)
{
  godot_string_get_data(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_string_get_data(PyObject *self, PyObject *args)
{
  godot_string const * x0;
  wchar_t * x1;
  int * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "godot_string_get_data", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(36), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(15), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (wchar_t *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(15), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(259), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (int *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(259), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_string_get_data(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_string_get_data _cffi_d_godot_string_get_data
#endif

static void _cffi_d_godot_string_new(godot_string * x0)
{
  godot_string_new(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_string_new(PyObject *self, PyObject *arg0)
{
  godot_string * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(240), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_string *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(240), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_string_new(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_string_new _cffi_d_godot_string_new
#endif

static void _cffi_d_godot_string_new_data(godot_string * x0, char const * x1, int x2)
{
  godot_string_new_data(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_string_new_data(PyObject *self, PyObject *args)
{
  godot_string * x0;
  char const * x1;
  int x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "godot_string_new_data", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(240), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_string *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(240), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(80), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(80), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_string_new_data(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_string_new_data _cffi_d_godot_string_new_data
#endif

static _Bool _cffi_d_godot_string_operator_equal(godot_string const * x0, godot_string const * x1)
{
  return godot_string_operator_equal(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_string_operator_equal(PyObject *self, PyObject *args)
{
  godot_string const * x0;
  godot_string const * x1;
  Py_ssize_t datasize;
  _Bool result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_string_operator_equal", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(36), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(36), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_string_operator_equal(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_string_operator_equal _cffi_d_godot_string_operator_equal
#endif

static wchar_t * _cffi_d_godot_string_operator_index(godot_string * x0, int x1)
{
  return godot_string_operator_index(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_string_operator_index(PyObject *self, PyObject *args)
{
  godot_string * x0;
  int x1;
  Py_ssize_t datasize;
  wchar_t * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_string_operator_index", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(240), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_string *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(240), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_string_operator_index(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(15));
}
#else
#  define _cffi_f_godot_string_operator_index _cffi_d_godot_string_operator_index
#endif

static _Bool _cffi_d_godot_string_operator_less(godot_string const * x0, godot_string const * x1)
{
  return godot_string_operator_less(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_string_operator_less(PyObject *self, PyObject *args)
{
  godot_string const * x0;
  godot_string const * x1;
  Py_ssize_t datasize;
  _Bool result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_string_operator_less", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(36), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(36), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_string_operator_less(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_string_operator_less _cffi_d_godot_string_operator_less
#endif

static void _cffi_d_godot_string_operator_plus(godot_string * x0, godot_string const * x1, godot_string const * x2)
{
  godot_string_operator_plus(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_string_operator_plus(PyObject *self, PyObject *args)
{
  godot_string * x0;
  godot_string const * x1;
  godot_string const * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "godot_string_operator_plus", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(240), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_string *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(240), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(36), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(36), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_string_operator_plus(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_string_operator_plus _cffi_d_godot_string_operator_plus
#endif

static godot_array _cffi_d_godot_variant_as_array(godot_variant const * x0)
{
  return godot_variant_as_array(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_as_array(PyObject *self, PyObject *arg0)
{
  godot_variant const * x0;
  Py_ssize_t datasize;
  godot_array result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(22), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_as_array(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(327));
}
#else
static void _cffi_f_godot_variant_as_array(godot_array *result, godot_variant const * x0)
{
  { *result = godot_variant_as_array(x0); }
}
#endif

static _Bool _cffi_d_godot_variant_as_bool(godot_variant const * x0)
{
  return godot_variant_as_bool(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_as_bool(PyObject *self, PyObject *arg0)
{
  godot_variant const * x0;
  Py_ssize_t datasize;
  _Bool result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(22), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_as_bool(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_variant_as_bool _cffi_d_godot_variant_as_bool
#endif

static godot_dictionary _cffi_d_godot_variant_as_dictionary(godot_variant const * x0)
{
  return godot_variant_as_dictionary(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_as_dictionary(PyObject *self, PyObject *arg0)
{
  godot_variant const * x0;
  Py_ssize_t datasize;
  godot_dictionary result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(22), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_as_dictionary(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(328));
}
#else
static void _cffi_f_godot_variant_as_dictionary(godot_dictionary *result, godot_variant const * x0)
{
  { *result = godot_variant_as_dictionary(x0); }
}
#endif

static uint64_t _cffi_d_godot_variant_as_int(godot_variant const * x0)
{
  return godot_variant_as_int(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_as_int(PyObject *self, PyObject *arg0)
{
  godot_variant const * x0;
  Py_ssize_t datasize;
  uint64_t result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(22), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_as_int(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, uint64_t);
}
#else
#  define _cffi_f_godot_variant_as_int _cffi_d_godot_variant_as_int
#endif

static float _cffi_d_godot_variant_as_real(godot_variant const * x0)
{
  return godot_variant_as_real(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_as_real(PyObject *self, PyObject *arg0)
{
  godot_variant const * x0;
  Py_ssize_t datasize;
  float result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(22), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_as_real(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_float(result);
}
#else
#  define _cffi_f_godot_variant_as_real _cffi_d_godot_variant_as_real
#endif

static godot_string _cffi_d_godot_variant_as_string(godot_variant const * x0)
{
  return godot_variant_as_string(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_as_string(PyObject *self, PyObject *arg0)
{
  godot_variant const * x0;
  Py_ssize_t datasize;
  godot_string result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(22), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_as_string(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(331));
}
#else
static void _cffi_f_godot_variant_as_string(godot_string *result, godot_variant const * x0)
{
  { *result = godot_variant_as_string(x0); }
}
#endif

static _Bool _cffi_d_godot_variant_booleanize(godot_variant const * x0, _Bool * x1)
{
  return godot_variant_booleanize(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_booleanize(PyObject *self, PyObject *args)
{
  godot_variant const * x0;
  _Bool * x1;
  Py_ssize_t datasize;
  _Bool result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_variant_booleanize", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(22), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(48), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (_Bool *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(48), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_booleanize(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_variant_booleanize _cffi_d_godot_variant_booleanize
#endif

static godot_variant _cffi_d_godot_variant_call(godot_variant * x0, godot_string const * x1, godot_variant const * * x2, int x3)
{
  return godot_variant_call(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_call(PyObject *self, PyObject *args)
{
  godot_variant * x0;
  godot_string const * x1;
  godot_variant const * * x2;
  int x3;
  Py_ssize_t datasize;
  godot_variant result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "godot_variant_call", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(40), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(36), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(95), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (godot_variant const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(95), arg2) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_call(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(333));
}
#else
static void _cffi_f_godot_variant_call(godot_variant *result, godot_variant * x0, godot_string const * x1, godot_variant const * * x2, int x3)
{
  { *result = godot_variant_call(x0, x1, x2, x3); }
}
#endif

static void _cffi_d_godot_variant_copy(godot_variant * x0, godot_variant const * x1)
{
  godot_variant_copy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_copy(PyObject *self, PyObject *args)
{
  godot_variant * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_variant_copy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(40), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_variant_copy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_variant_copy _cffi_d_godot_variant_copy
#endif

static void _cffi_d_godot_variant_destroy(godot_variant * x0)
{
  godot_variant_destroy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_destroy(PyObject *self, PyObject *arg0)
{
  godot_variant * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(40), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_variant_destroy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_variant_destroy _cffi_d_godot_variant_destroy
#endif

static enum godot_variant_type _cffi_d_godot_variant_get_type(godot_variant const * x0)
{
  return godot_variant_get_type(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_get_type(PyObject *self, PyObject *arg0)
{
  godot_variant const * x0;
  Py_ssize_t datasize;
  enum godot_variant_type result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(22), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_get_type(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_deref((char *)&result, _cffi_type(326));
}
#else
#  define _cffi_f_godot_variant_get_type _cffi_d_godot_variant_get_type
#endif

static _Bool _cffi_d_godot_variant_has_method(godot_variant * x0, godot_string const * x1)
{
  return godot_variant_has_method(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_has_method(PyObject *self, PyObject *args)
{
  godot_variant * x0;
  godot_string const * x1;
  Py_ssize_t datasize;
  _Bool result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_variant_has_method", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(40), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(36), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_has_method(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_variant_has_method _cffi_d_godot_variant_has_method
#endif

static _Bool _cffi_d_godot_variant_hash_compare(godot_variant const * x0, godot_variant const * x1)
{
  return godot_variant_hash_compare(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_hash_compare(PyObject *self, PyObject *args)
{
  godot_variant const * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  _Bool result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_variant_hash_compare", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(22), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_hash_compare(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_variant_hash_compare _cffi_d_godot_variant_hash_compare
#endif

static void _cffi_d_godot_variant_new_bool(godot_variant * x0, _Bool x1)
{
  godot_variant_new_bool(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_new_bool(PyObject *self, PyObject *args)
{
  godot_variant * x0;
  _Bool x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_variant_new_bool", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(40), arg0) < 0)
      return NULL;
  }

  x1 = (_Bool)_cffi_to_c__Bool(arg1);
  if (x1 == (_Bool)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_variant_new_bool(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_variant_new_bool _cffi_d_godot_variant_new_bool
#endif

static void _cffi_d_godot_variant_new_int(godot_variant * x0, uint64_t x1)
{
  godot_variant_new_int(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_new_int(PyObject *self, PyObject *args)
{
  godot_variant * x0;
  uint64_t x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_variant_new_int", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(40), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, uint64_t);
  if (x1 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_variant_new_int(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_variant_new_int _cffi_d_godot_variant_new_int
#endif

static void _cffi_d_godot_variant_new_nil(godot_variant * x0)
{
  godot_variant_new_nil(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_new_nil(PyObject *self, PyObject *arg0)
{
  godot_variant * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(40), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_variant_new_nil(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_variant_new_nil _cffi_d_godot_variant_new_nil
#endif

static void _cffi_d_godot_variant_new_real(godot_variant * x0, double x1)
{
  godot_variant_new_real(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_new_real(PyObject *self, PyObject *args)
{
  godot_variant * x0;
  double x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_variant_new_real", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(40), arg0) < 0)
      return NULL;
  }

  x1 = (double)_cffi_to_c_double(arg1);
  if (x1 == (double)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_variant_new_real(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_variant_new_real _cffi_d_godot_variant_new_real
#endif

static void _cffi_d_godot_variant_new_string(godot_variant * x0, godot_string const * x1)
{
  godot_variant_new_string(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_new_string(PyObject *self, PyObject *args)
{
  godot_variant * x0;
  godot_string const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_variant_new_string", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(40), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(40), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(36), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_string const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(36), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_variant_new_string(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_variant_new_string _cffi_d_godot_variant_new_string
#endif

static _Bool _cffi_d_godot_variant_operator_equal(godot_variant const * x0, godot_variant const * x1)
{
  return godot_variant_operator_equal(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_operator_equal(PyObject *self, PyObject *args)
{
  godot_variant const * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  _Bool result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_variant_operator_equal", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(22), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_operator_equal(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_variant_operator_equal _cffi_d_godot_variant_operator_equal
#endif

static _Bool _cffi_d_godot_variant_operator_less(godot_variant const * x0, godot_variant const * x1)
{
  return godot_variant_operator_less(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_variant_operator_less(PyObject *self, PyObject *args)
{
  godot_variant const * x0;
  godot_variant const * x1;
  Py_ssize_t datasize;
  _Bool result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_variant_operator_less", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(22), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(22), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_variant const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(22), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_variant_operator_less(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, _Bool);
}
#else
#  define _cffi_f_godot_variant_operator_less _cffi_d_godot_variant_operator_less
#endif

static float _cffi_d_godot_vector2_distance_squared_to(godot_vector2 const * x0, godot_vector2 const * x1)
{
  return godot_vector2_distance_squared_to(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_vector2_distance_squared_to(PyObject *self, PyObject *args)
{
  godot_vector2 const * x0;
  godot_vector2 const * x1;
  Py_ssize_t datasize;
  float result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_vector2_distance_squared_to", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(64), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_vector2 const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(64), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(64), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_vector2 const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(64), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_vector2_distance_squared_to(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_float(result);
}
#else
#  define _cffi_f_godot_vector2_distance_squared_to _cffi_d_godot_vector2_distance_squared_to
#endif

static float _cffi_d_godot_vector2_distance_to(godot_vector2 const * x0, godot_vector2 const * x1)
{
  return godot_vector2_distance_to(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_vector2_distance_to(PyObject *self, PyObject *args)
{
  godot_vector2 const * x0;
  godot_vector2 const * x1;
  Py_ssize_t datasize;
  float result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_vector2_distance_to", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(64), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_vector2 const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(64), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(64), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_vector2 const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(64), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_vector2_distance_to(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_float(result);
}
#else
#  define _cffi_f_godot_vector2_distance_to _cffi_d_godot_vector2_distance_to
#endif

static float _cffi_d_godot_vector2_get_x(godot_vector2 const * x0)
{
  return godot_vector2_get_x(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_vector2_get_x(PyObject *self, PyObject *arg0)
{
  godot_vector2 const * x0;
  Py_ssize_t datasize;
  float result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(64), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_vector2 const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(64), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_vector2_get_x(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_float(result);
}
#else
#  define _cffi_f_godot_vector2_get_x _cffi_d_godot_vector2_get_x
#endif

static float _cffi_d_godot_vector2_get_y(godot_vector2 const * x0)
{
  return godot_vector2_get_y(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_vector2_get_y(PyObject *self, PyObject *arg0)
{
  godot_vector2 const * x0;
  Py_ssize_t datasize;
  float result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(64), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_vector2 const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(64), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_vector2_get_y(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_float(result);
}
#else
#  define _cffi_f_godot_vector2_get_y _cffi_d_godot_vector2_get_y
#endif

static float _cffi_d_godot_vector2_length(godot_vector2 const * x0)
{
  return godot_vector2_length(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_vector2_length(PyObject *self, PyObject *arg0)
{
  godot_vector2 const * x0;
  Py_ssize_t datasize;
  float result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(64), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_vector2 const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(64), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_vector2_length(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_float(result);
}
#else
#  define _cffi_f_godot_vector2_length _cffi_d_godot_vector2_length
#endif

static float _cffi_d_godot_vector2_length_squared(godot_vector2 const * x0)
{
  return godot_vector2_length_squared(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_vector2_length_squared(PyObject *self, PyObject *arg0)
{
  godot_vector2 const * x0;
  Py_ssize_t datasize;
  float result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(64), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_vector2 const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(64), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = godot_vector2_length_squared(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_float(result);
}
#else
#  define _cffi_f_godot_vector2_length_squared _cffi_d_godot_vector2_length_squared
#endif

static void _cffi_d_godot_vector2_new(godot_vector2 * x0, float x1, float x2)
{
  godot_vector2_new(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_vector2_new(PyObject *self, PyObject *args)
{
  godot_vector2 * x0;
  float x1;
  float x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "godot_vector2_new", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(285), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_vector2 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(285), arg0) < 0)
      return NULL;
  }

  x1 = (float)_cffi_to_c_float(arg1);
  if (x1 == (float)-1 && PyErr_Occurred())
    return NULL;

  x2 = (float)_cffi_to_c_float(arg2);
  if (x2 == (float)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_vector2_new(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_vector2_new _cffi_d_godot_vector2_new
#endif

static void _cffi_d_godot_vector2_normalize(godot_vector2 * x0)
{
  godot_vector2_normalize(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_vector2_normalize(PyObject *self, PyObject *arg0)
{
  godot_vector2 * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(285), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_vector2 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(285), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_vector2_normalize(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_vector2_normalize _cffi_d_godot_vector2_normalize
#endif

static void _cffi_d_godot_vector2_normalized(godot_vector2 * x0, godot_vector2 const * x1)
{
  godot_vector2_normalized(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_vector2_normalized(PyObject *self, PyObject *args)
{
  godot_vector2 * x0;
  godot_vector2 const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_vector2_normalized", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(285), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_vector2 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(285), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(64), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (godot_vector2 const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(64), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_vector2_normalized(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_vector2_normalized _cffi_d_godot_vector2_normalized
#endif

static void _cffi_d_godot_vector2_set_x(godot_vector2 * x0, float x1)
{
  godot_vector2_set_x(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_vector2_set_x(PyObject *self, PyObject *args)
{
  godot_vector2 * x0;
  float x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_vector2_set_x", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(285), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_vector2 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(285), arg0) < 0)
      return NULL;
  }

  x1 = (float)_cffi_to_c_float(arg1);
  if (x1 == (float)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_vector2_set_x(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_vector2_set_x _cffi_d_godot_vector2_set_x
#endif

static void _cffi_d_godot_vector2_set_y(godot_vector2 * x0, float x1)
{
  godot_vector2_set_y(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_godot_vector2_set_y(PyObject *self, PyObject *args)
{
  godot_vector2 * x0;
  float x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "godot_vector2_set_y", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(285), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (godot_vector2 *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(285), arg0) < 0)
      return NULL;
  }

  x1 = (float)_cffi_to_c_float(arg1);
  if (x1 == (float)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { godot_vector2_set_y(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_godot_vector2_set_y _cffi_d_godot_vector2_set_y
#endif

_CFFI_UNUSED_FN
static void _cffi_checkfld__godot_array(godot_array *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { uint8_t(*tmp)[8] = &p->_dont_touch_that; (void)tmp; }
}
struct _cffi_align__godot_array { char x; godot_array y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__godot_dictionary(godot_dictionary *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { uint8_t(*tmp)[8] = &p->_dont_touch_that; (void)tmp; }
}
struct _cffi_align__godot_dictionary { char x; godot_dictionary y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__godot_method_bind(godot_method_bind *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { uint8_t(*tmp)[1] = &p->_dont_touch_that; (void)tmp; }
}
struct _cffi_align__godot_method_bind { char x; godot_method_bind y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__godot_pool_string_array(godot_pool_string_array *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { uint8_t(*tmp)[8] = &p->_dont_touch_that; (void)tmp; }
}
struct _cffi_align__godot_pool_string_array { char x; godot_pool_string_array y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__godot_string(godot_string *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { uint8_t(*tmp)[8] = &p->_dont_touch_that; (void)tmp; }
}
struct _cffi_align__godot_string { char x; godot_string y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__godot_variant(godot_variant *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { uint8_t(*tmp)[24] = &p->_dont_touch_that; (void)tmp; }
}
struct _cffi_align__godot_variant { char x; godot_variant y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld__godot_vector2(godot_vector2 *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { uint8_t(*tmp)[8] = &p->_dont_touch_that; (void)tmp; }
}
struct _cffi_align__godot_vector2 { char x; godot_vector2 y; };

static const struct _cffi_global_s _cffi_globals[] = {
  { "GODOT_VARIANT_TYPE_ARRAY", (void *)_cffi_const_GODOT_VARIANT_TYPE_ARRAY, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_BASIS", (void *)_cffi_const_GODOT_VARIANT_TYPE_BASIS, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_BOOL", (void *)_cffi_const_GODOT_VARIANT_TYPE_BOOL, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_COLOR", (void *)_cffi_const_GODOT_VARIANT_TYPE_COLOR, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_DICTIONARY", (void *)_cffi_const_GODOT_VARIANT_TYPE_DICTIONARY, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_IMAGE", (void *)_cffi_const_GODOT_VARIANT_TYPE_IMAGE, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_INPUT_EVENT", (void *)_cffi_const_GODOT_VARIANT_TYPE_INPUT_EVENT, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_INT", (void *)_cffi_const_GODOT_VARIANT_TYPE_INT, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_NIL", (void *)_cffi_const_GODOT_VARIANT_TYPE_NIL, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_NODE_PATH", (void *)_cffi_const_GODOT_VARIANT_TYPE_NODE_PATH, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_OBJECT", (void *)_cffi_const_GODOT_VARIANT_TYPE_OBJECT, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_PLANE", (void *)_cffi_const_GODOT_VARIANT_TYPE_PLANE, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY", (void *)_cffi_const_GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY", (void *)_cffi_const_GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_POOL_INT_ARRAY", (void *)_cffi_const_GODOT_VARIANT_TYPE_POOL_INT_ARRAY, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_POOL_REAL_ARRAY", (void *)_cffi_const_GODOT_VARIANT_TYPE_POOL_REAL_ARRAY, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_POOL_STRING_ARRAY", (void *)_cffi_const_GODOT_VARIANT_TYPE_POOL_STRING_ARRAY, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY", (void *)_cffi_const_GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY", (void *)_cffi_const_GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_QUAT", (void *)_cffi_const_GODOT_VARIANT_TYPE_QUAT, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_REAL", (void *)_cffi_const_GODOT_VARIANT_TYPE_REAL, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_RECT2", (void *)_cffi_const_GODOT_VARIANT_TYPE_RECT2, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_RECT3", (void *)_cffi_const_GODOT_VARIANT_TYPE_RECT3, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_RID", (void *)_cffi_const_GODOT_VARIANT_TYPE_RID, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_STRING", (void *)_cffi_const_GODOT_VARIANT_TYPE_STRING, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_TRANSFORM", (void *)_cffi_const_GODOT_VARIANT_TYPE_TRANSFORM, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_TRANSFORM2D", (void *)_cffi_const_GODOT_VARIANT_TYPE_TRANSFORM2D, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_VECTOR2", (void *)_cffi_const_GODOT_VARIANT_TYPE_VECTOR2, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "GODOT_VARIANT_TYPE_VECTOR3", (void *)_cffi_const_GODOT_VARIANT_TYPE_VECTOR3, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "METHOD_FLAGS_DEFAULT", (void *)_cffi_const_METHOD_FLAGS_DEFAULT, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "METHOD_FLAG_CONST", (void *)_cffi_const_METHOD_FLAG_CONST, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "METHOD_FLAG_EDITOR", (void *)_cffi_const_METHOD_FLAG_EDITOR, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "METHOD_FLAG_FROM_SCRIPT", (void *)_cffi_const_METHOD_FLAG_FROM_SCRIPT, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "METHOD_FLAG_NORMAL", (void *)_cffi_const_METHOD_FLAG_NORMAL, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "METHOD_FLAG_NOSCRIPT", (void *)_cffi_const_METHOD_FLAG_NOSCRIPT, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "METHOD_FLAG_REVERSE", (void *)_cffi_const_METHOD_FLAG_REVERSE, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "METHOD_FLAG_VARARG", (void *)_cffi_const_METHOD_FLAG_VARARG, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "METHOD_FLAG_VIRTUAL", (void *)_cffi_const_METHOD_FLAG_VIRTUAL, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "call_with_variants", (void *)&_cffi_externpy__call_with_variants, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 332), (void *)call_with_variants },
  { "do_stuff", (void *)&_cffi_externpy__do_stuff, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 335), (void *)do_stuff },
  { "godot_array_append", (void *)_cffi_f_godot_array_append, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 184), (void *)_cffi_d_godot_array_append },
  { "godot_array_back", (void *)_cffi_f_godot_array_back, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 109), (void *)_cffi_d_godot_array_back },
  { "godot_array_clear", (void *)_cffi_f_godot_array_clear, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 181), (void *)_cffi_d_godot_array_clear },
  { "godot_array_count", (void *)_cffi_f_godot_array_count, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 118), (void *)_cffi_d_godot_array_count },
  { "godot_array_destroy", (void *)_cffi_f_godot_array_destroy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 181), (void *)_cffi_d_godot_array_destroy },
  { "godot_array_empty", (void *)_cffi_f_godot_array_empty, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 17), (void *)_cffi_d_godot_array_empty },
  { "godot_array_erase", (void *)_cffi_f_godot_array_erase, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 184), (void *)_cffi_d_godot_array_erase },
  { "godot_array_find", (void *)_cffi_f_godot_array_find, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 129), (void *)_cffi_d_godot_array_find },
  { "godot_array_find_last", (void *)_cffi_f_godot_array_find_last, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 125), (void *)_cffi_d_godot_array_find_last },
  { "godot_array_front", (void *)_cffi_f_godot_array_front, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 109), (void *)_cffi_d_godot_array_front },
  { "godot_array_get", (void *)_cffi_f_godot_array_get, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 98), (void *)_cffi_d_godot_array_get },
  { "godot_array_has", (void *)_cffi_f_godot_array_has, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 20), (void *)_cffi_d_godot_array_has },
  { "godot_array_hash", (void *)_cffi_f_godot_array_hash, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 158), (void *)_cffi_d_godot_array_hash },
  { "godot_array_insert", (void *)_cffi_f_godot_array_insert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 192), (void *)_cffi_d_godot_array_insert },
  { "godot_array_invert", (void *)_cffi_f_godot_array_invert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 181), (void *)_cffi_d_godot_array_invert },
  { "godot_array_is_shared", (void *)_cffi_f_godot_array_is_shared, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 17), (void *)_cffi_d_godot_array_is_shared },
  { "godot_array_pop_back", (void *)_cffi_f_godot_array_pop_back, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 106), (void *)_cffi_d_godot_array_pop_back },
  { "godot_array_pop_front", (void *)_cffi_f_godot_array_pop_front, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 106), (void *)_cffi_d_godot_array_pop_front },
  { "godot_array_push_back", (void *)_cffi_f_godot_array_push_back, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 184), (void *)_cffi_d_godot_array_push_back },
  { "godot_array_push_front", (void *)_cffi_f_godot_array_push_front, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 184), (void *)_cffi_d_godot_array_push_front },
  { "godot_array_remove", (void *)_cffi_f_godot_array_remove, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 188), (void *)_cffi_d_godot_array_remove },
  { "godot_array_resize", (void *)_cffi_f_godot_array_resize, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 188), (void *)_cffi_d_godot_array_resize },
  { "godot_array_rfind", (void *)_cffi_f_godot_array_rfind, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 129), (void *)_cffi_d_godot_array_rfind },
  { "godot_array_set", (void *)_cffi_f_godot_array_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 192), (void *)_cffi_d_godot_array_set },
  { "godot_array_size", (void *)_cffi_f_godot_array_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 122), (void *)_cffi_d_godot_array_size },
  { "godot_array_sort", (void *)_cffi_f_godot_array_sort, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 181), (void *)_cffi_d_godot_array_sort },
  { "godot_array_sort_custom", (void *)_cffi_f_godot_array_sort_custom, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 197), (void *)_cffi_d_godot_array_sort_custom },
  { "godot_dictionary_clear", (void *)_cffi_f_godot_dictionary_clear, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 202), (void *)_cffi_d_godot_dictionary_clear },
  { "godot_dictionary_destroy", (void *)_cffi_f_godot_dictionary_destroy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 202), (void *)_cffi_d_godot_dictionary_destroy },
  { "godot_dictionary_empty", (void *)_cffi_f_godot_dictionary_empty, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 24), (void *)_cffi_d_godot_dictionary_empty },
  { "godot_dictionary_erase", (void *)_cffi_f_godot_dictionary_erase, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 205), (void *)_cffi_d_godot_dictionary_erase },
  { "godot_dictionary_has", (void *)_cffi_f_godot_dictionary_has, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 31), (void *)_cffi_d_godot_dictionary_has },
  { "godot_dictionary_has_all", (void *)_cffi_f_godot_dictionary_has_all, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 27), (void *)_cffi_d_godot_dictionary_has_all },
  { "godot_dictionary_hash", (void *)_cffi_f_godot_dictionary_hash, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 161), (void *)_cffi_d_godot_dictionary_hash },
  { "godot_dictionary_keys", (void *)_cffi_f_godot_dictionary_keys, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 70), (void *)_cffi_d_godot_dictionary_keys },
  { "godot_dictionary_new", (void *)_cffi_f_godot_dictionary_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 202), (void *)_cffi_d_godot_dictionary_new },
  { "godot_dictionary_operator_index", (void *)_cffi_f_godot_dictionary_operator_index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 102), (void *)_cffi_d_godot_dictionary_operator_index },
  { "godot_dictionary_parse_json", (void *)_cffi_f_godot_dictionary_parse_json, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 134), (void *)_cffi_d_godot_dictionary_parse_json },
  { "godot_dictionary_size", (void *)_cffi_f_godot_dictionary_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 138), (void *)_cffi_d_godot_dictionary_size },
  { "godot_dictionary_to_json", (void *)_cffi_f_godot_dictionary_to_json, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 83), (void *)_cffi_d_godot_dictionary_to_json },
  { "godot_dictionary_values", (void *)_cffi_f_godot_dictionary_values, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 70), (void *)_cffi_d_godot_dictionary_values },
  { "godot_get_global_constant_count", (void *)_cffi_f_godot_get_global_constant_count, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 156), (void *)_cffi_d_godot_get_global_constant_count },
  { "godot_get_global_constant_name", (void *)_cffi_f_godot_get_global_constant_name, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 54), (void *)_cffi_d_godot_get_global_constant_name },
  { "godot_get_global_constant_value", (void *)_cffi_f_godot_get_global_constant_value, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 149), (void *)_cffi_d_godot_get_global_constant_value },
  { "godot_global_get_singleton", (void *)_cffi_f_godot_global_get_singleton, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 167), (void *)_cffi_d_godot_global_get_singleton },
  { "godot_method_bind_get_method", (void *)_cffi_f_godot_method_bind_get_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 79), (void *)_cffi_d_godot_method_bind_get_method },
  { "godot_method_bind_ptrcall", (void *)_cffi_f_godot_method_bind_ptrcall, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 209), (void *)_cffi_d_godot_method_bind_ptrcall },
  { "godot_pool_string_array_append", (void *)_cffi_f_godot_pool_string_array_append, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 226), (void *)_cffi_d_godot_pool_string_array_append },
  { "godot_pool_string_array_append_array", (void *)_cffi_f_godot_pool_string_array_append_array, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 222), (void *)_cffi_d_godot_pool_string_array_append_array },
  { "godot_pool_string_array_destroy", (void *)_cffi_f_godot_pool_string_array_destroy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 215), (void *)_cffi_d_godot_pool_string_array_destroy },
  { "godot_pool_string_array_get", (void *)_cffi_f_godot_pool_string_array_get, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 86), (void *)_cffi_d_godot_pool_string_array_get },
  { "godot_pool_string_array_insert", (void *)_cffi_f_godot_pool_string_array_insert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 144), (void *)_cffi_d_godot_pool_string_array_insert },
  { "godot_pool_string_array_invert", (void *)_cffi_f_godot_pool_string_array_invert, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 215), (void *)_cffi_d_godot_pool_string_array_invert },
  { "godot_pool_string_array_new", (void *)_cffi_f_godot_pool_string_array_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 215), (void *)_cffi_d_godot_pool_string_array_new },
  { "godot_pool_string_array_new_with_array", (void *)_cffi_f_godot_pool_string_array_new_with_array, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 218), (void *)_cffi_d_godot_pool_string_array_new_with_array },
  { "godot_pool_string_array_push_back", (void *)_cffi_f_godot_pool_string_array_push_back, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 226), (void *)_cffi_d_godot_pool_string_array_push_back },
  { "godot_pool_string_array_remove", (void *)_cffi_f_godot_pool_string_array_remove, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 230), (void *)_cffi_d_godot_pool_string_array_remove },
  { "godot_pool_string_array_resize", (void *)_cffi_f_godot_pool_string_array_resize, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 230), (void *)_cffi_d_godot_pool_string_array_resize },
  { "godot_pool_string_array_set", (void *)_cffi_f_godot_pool_string_array_set, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 234), (void *)_cffi_d_godot_pool_string_array_set },
  { "godot_pool_string_array_size", (void *)_cffi_f_godot_pool_string_array_size, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 141), (void *)_cffi_d_godot_pool_string_array_size },
  { "godot_string_c_str", (void *)_cffi_f_godot_string_c_str, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 315), (void *)_cffi_d_godot_string_c_str },
  { "godot_string_copy_string", (void *)_cffi_f_godot_string_copy_string, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 252), (void *)_cffi_d_godot_string_copy_string },
  { "godot_string_get_data", (void *)_cffi_f_godot_string_get_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 256), (void *)_cffi_d_godot_string_get_data },
  { "godot_string_new", (void *)_cffi_f_godot_string_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 239), (void *)_cffi_d_godot_string_new },
  { "godot_string_new_data", (void *)_cffi_f_godot_string_new_data, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 242), (void *)_cffi_d_godot_string_new_data },
  { "godot_string_operator_equal", (void *)_cffi_f_godot_string_operator_equal, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 35), (void *)_cffi_d_godot_string_operator_equal },
  { "godot_string_operator_index", (void *)_cffi_f_godot_string_operator_index, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 311), (void *)_cffi_d_godot_string_operator_index },
  { "godot_string_operator_less", (void *)_cffi_f_godot_string_operator_less, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 35), (void *)_cffi_d_godot_string_operator_less },
  { "godot_string_operator_plus", (void *)_cffi_f_godot_string_operator_plus, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 247), (void *)_cffi_d_godot_string_operator_plus },
  { "godot_variant_as_array", (void *)_cffi_f_godot_variant_as_array, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 73), (void *)_cffi_d_godot_variant_as_array },
  { "godot_variant_as_bool", (void *)_cffi_f_godot_variant_as_bool, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 43), (void *)_cffi_d_godot_variant_as_bool },
  { "godot_variant_as_dictionary", (void *)_cffi_f_godot_variant_as_dictionary, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 76), (void *)_cffi_d_godot_variant_as_dictionary },
  { "godot_variant_as_int", (void *)_cffi_f_godot_variant_as_int, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 164), (void *)_cffi_d_godot_variant_as_int },
  { "godot_variant_as_real", (void *)_cffi_f_godot_variant_as_real, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 60), (void *)_cffi_d_godot_variant_as_real },
  { "godot_variant_as_string", (void *)_cffi_f_godot_variant_as_string, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 90), (void *)_cffi_d_godot_variant_as_string },
  { "godot_variant_booleanize", (void *)_cffi_f_godot_variant_booleanize, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 46), (void *)_cffi_d_godot_variant_booleanize },
  { "godot_variant_call", (void *)_cffi_f_godot_variant_call, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 112), (void *)_cffi_d_godot_variant_call },
  { "godot_variant_copy", (void *)_cffi_f_godot_variant_copy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 276), (void *)_cffi_d_godot_variant_copy },
  { "godot_variant_destroy", (void *)_cffi_f_godot_variant_destroy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 261), (void *)_cffi_d_godot_variant_destroy },
  { "godot_variant_get_type", (void *)_cffi_f_godot_variant_get_type, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 57), (void *)_cffi_d_godot_variant_get_type },
  { "godot_variant_has_method", (void *)_cffi_f_godot_variant_has_method, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 39), (void *)_cffi_d_godot_variant_has_method },
  { "godot_variant_hash_compare", (void *)_cffi_f_godot_variant_hash_compare, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 50), (void *)_cffi_d_godot_variant_hash_compare },
  { "godot_variant_new_bool", (void *)_cffi_f_godot_variant_new_bool, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 264), (void *)_cffi_d_godot_variant_new_bool },
  { "godot_variant_new_int", (void *)_cffi_f_godot_variant_new_int, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 280), (void *)_cffi_d_godot_variant_new_int },
  { "godot_variant_new_nil", (void *)_cffi_f_godot_variant_new_nil, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 261), (void *)_cffi_d_godot_variant_new_nil },
  { "godot_variant_new_real", (void *)_cffi_f_godot_variant_new_real, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 268), (void *)_cffi_d_godot_variant_new_real },
  { "godot_variant_new_string", (void *)_cffi_f_godot_variant_new_string, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 272), (void *)_cffi_d_godot_variant_new_string },
  { "godot_variant_operator_equal", (void *)_cffi_f_godot_variant_operator_equal, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 50), (void *)_cffi_d_godot_variant_operator_equal },
  { "godot_variant_operator_less", (void *)_cffi_f_godot_variant_operator_less, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 50), (void *)_cffi_d_godot_variant_operator_less },
  { "godot_vector2_distance_squared_to", (void *)_cffi_f_godot_vector2_distance_squared_to, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 66), (void *)_cffi_d_godot_vector2_distance_squared_to },
  { "godot_vector2_distance_to", (void *)_cffi_f_godot_vector2_distance_to, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 66), (void *)_cffi_d_godot_vector2_distance_to },
  { "godot_vector2_get_x", (void *)_cffi_f_godot_vector2_get_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 63), (void *)_cffi_d_godot_vector2_get_x },
  { "godot_vector2_get_y", (void *)_cffi_f_godot_vector2_get_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 63), (void *)_cffi_d_godot_vector2_get_y },
  { "godot_vector2_length", (void *)_cffi_f_godot_vector2_length, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 63), (void *)_cffi_d_godot_vector2_length },
  { "godot_vector2_length_squared", (void *)_cffi_f_godot_vector2_length_squared, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 63), (void *)_cffi_d_godot_vector2_length_squared },
  { "godot_vector2_new", (void *)_cffi_f_godot_vector2_new, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 291), (void *)_cffi_d_godot_vector2_new },
  { "godot_vector2_normalize", (void *)_cffi_f_godot_vector2_normalize, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 284), (void *)_cffi_d_godot_vector2_normalize },
  { "godot_vector2_normalized", (void *)_cffi_f_godot_vector2_normalized, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 296), (void *)_cffi_d_godot_vector2_normalized },
  { "godot_vector2_set_x", (void *)_cffi_f_godot_vector2_set_x, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 287), (void *)_cffi_d_godot_vector2_set_x },
  { "godot_vector2_set_y", (void *)_cffi_f_godot_vector2_set_y, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 287), (void *)_cffi_d_godot_vector2_set_y },
  { "instanciate_binding_from_godot_obj", (void *)&_cffi_externpy__instanciate_binding_from_godot_obj, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 319), (void *)instanciate_binding_from_godot_obj },
  { "py_instance_set_godot_obj", (void *)&_cffi_externpy__py_instance_set_godot_obj, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 347), (void *)py_instance_set_godot_obj },
  { "pybind_call_meth", (void *)&_cffi_externpy__pybind_call_meth, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 349), (void *)pybind_call_meth },
  { "pybind_instanciate_from_classname", (void *)&_cffi_externpy__pybind_instanciate_from_classname, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 345), (void *)pybind_instanciate_from_classname },
  { "pybind_load_exposed_class_per_module", (void *)&_cffi_externpy__pybind_load_exposed_class_per_module, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 345), (void *)pybind_load_exposed_class_per_module },
  { "pybind_module_from_name", (void *)&_cffi_externpy__pybind_module_from_name, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 322), (void *)pybind_module_from_name },
  { "pybind_release_instance", (void *)&_cffi_externpy__pybind_release_instance, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 348), (void *)pybind_release_instance },
  { "pybind_wrap_gdobj_with_class", (void *)&_cffi_externpy__pybind_wrap_gdobj_with_class, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 344), (void *)pybind_wrap_gdobj_with_class },
  { "pyobj_to_variant2", (void *)&_cffi_externpy__pyobj_to_variant2, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 318), (void *)pyobj_to_variant2 },
  { "variant_to_pyobj2", (void *)&_cffi_externpy__variant_to_pyobj2, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 321), (void *)variant_to_pyobj2 },
  { "variants_to_pyobjs", (void *)&_cffi_externpy__variants_to_pyobjs, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 320), (void *)variants_to_pyobjs },
};

static const struct _cffi_field_s _cffi_fields[] = {
  { "_dont_touch_that", offsetof(godot_array, _dont_touch_that),
                        sizeof(((godot_array *)0)->_dont_touch_that),
                        _CFFI_OP(_CFFI_OP_NOOP, 342) },
  { "_dont_touch_that", offsetof(godot_dictionary, _dont_touch_that),
                        sizeof(((godot_dictionary *)0)->_dont_touch_that),
                        _CFFI_OP(_CFFI_OP_NOOP, 342) },
  { "_dont_touch_that", offsetof(godot_method_bind, _dont_touch_that),
                        sizeof(((godot_method_bind *)0)->_dont_touch_that),
                        _CFFI_OP(_CFFI_OP_NOOP, 338) },
  { "_dont_touch_that", offsetof(godot_pool_string_array, _dont_touch_that),
                        sizeof(((godot_pool_string_array *)0)->_dont_touch_that),
                        _CFFI_OP(_CFFI_OP_NOOP, 342) },
  { "_dont_touch_that", offsetof(godot_string, _dont_touch_that),
                        sizeof(((godot_string *)0)->_dont_touch_that),
                        _CFFI_OP(_CFFI_OP_NOOP, 342) },
  { "_dont_touch_that", offsetof(godot_variant, _dont_touch_that),
                        sizeof(((godot_variant *)0)->_dont_touch_that),
                        _CFFI_OP(_CFFI_OP_NOOP, 340) },
  { "_dont_touch_that", offsetof(godot_vector2, _dont_touch_that),
                        sizeof(((godot_vector2 *)0)->_dont_touch_that),
                        _CFFI_OP(_CFFI_OP_NOOP, 342) },
};

static const struct _cffi_struct_union_s _cffi_struct_unions[] = {
  { "$PyObject", 323, 0,
    sizeof(PyObject), offsetof(struct _cffi_align_typedef_PyObject, y), 0, 0 },
  { "godot_array", 327, _CFFI_F_CHECK_FIELDS,
    sizeof(godot_array), offsetof(struct _cffi_align__godot_array, y), 0, 1 },
  { "godot_dictionary", 328, _CFFI_F_CHECK_FIELDS,
    sizeof(godot_dictionary), offsetof(struct _cffi_align__godot_dictionary, y), 1, 1 },
  { "godot_method_bind", 329, _CFFI_F_CHECK_FIELDS,
    sizeof(godot_method_bind), offsetof(struct _cffi_align__godot_method_bind, y), 2, 1 },
  { "godot_pool_string_array", 330, _CFFI_F_CHECK_FIELDS,
    sizeof(godot_pool_string_array), offsetof(struct _cffi_align__godot_pool_string_array, y), 3, 1 },
  { "godot_string", 331, _CFFI_F_CHECK_FIELDS,
    sizeof(godot_string), offsetof(struct _cffi_align__godot_string, y), 4, 1 },
  { "godot_variant", 333, _CFFI_F_CHECK_FIELDS,
    sizeof(godot_variant), offsetof(struct _cffi_align__godot_variant, y), 5, 1 },
  { "godot_vector2", 334, _CFFI_F_CHECK_FIELDS,
    sizeof(godot_vector2), offsetof(struct _cffi_align__godot_vector2, y), 6, 1 },
};

static const struct _cffi_enum_s _cffi_enums[] = {
  { "MethodFlags", 325, _cffi_prim_int(sizeof(enum MethodFlags), ((enum MethodFlags)-1) <= 0),
    "METHOD_FLAG_NORMAL,METHOD_FLAG_EDITOR,METHOD_FLAG_NOSCRIPT,METHOD_FLAG_CONST,METHOD_FLAG_REVERSE,METHOD_FLAG_VIRTUAL,METHOD_FLAG_FROM_SCRIPT,METHOD_FLAG_VARARG,METHOD_FLAGS_DEFAULT" },
  { "godot_variant_type", 326, _cffi_prim_int(sizeof(enum godot_variant_type), ((enum godot_variant_type)-1) <= 0),
    "GODOT_VARIANT_TYPE_NIL,GODOT_VARIANT_TYPE_BOOL,GODOT_VARIANT_TYPE_INT,GODOT_VARIANT_TYPE_REAL,GODOT_VARIANT_TYPE_STRING,GODOT_VARIANT_TYPE_VECTOR2,GODOT_VARIANT_TYPE_RECT2,GODOT_VARIANT_TYPE_VECTOR3,GODOT_VARIANT_TYPE_TRANSFORM2D,GODOT_VARIANT_TYPE_PLANE,GODOT_VARIANT_TYPE_QUAT,GODOT_VARIANT_TYPE_RECT3,GODOT_VARIANT_TYPE_BASIS,GODOT_VARIANT_TYPE_TRANSFORM,GODOT_VARIANT_TYPE_COLOR,GODOT_VARIANT_TYPE_IMAGE,GODOT_VARIANT_TYPE_NODE_PATH,GODOT_VARIANT_TYPE_RID,GODOT_VARIANT_TYPE_OBJECT,GODOT_VARIANT_TYPE_INPUT_EVENT,GODOT_VARIANT_TYPE_DICTIONARY,GODOT_VARIANT_TYPE_ARRAY,GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY,GODOT_VARIANT_TYPE_POOL_INT_ARRAY,GODOT_VARIANT_TYPE_POOL_REAL_ARRAY,GODOT_VARIANT_TYPE_POOL_STRING_ARRAY,GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY,GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY,GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY" },
};

static const struct _cffi_typename_s _cffi_typenames[] = {
  { "PyObject", 323 },
  { "godot_array", 327 },
  { "godot_bool", 266 },
  { "godot_dictionary", 328 },
  { "godot_int", 9 },
  { "godot_method_bind", 329 },
  { "godot_object", 350 },
  { "godot_pool_string_array", 330 },
  { "godot_real", 289 },
  { "godot_real64", 270 },
  { "godot_string", 331 },
  { "godot_variant", 333 },
  { "godot_variant_type", 326 },
  { "godot_vector2", 334 },
};

static const struct _cffi_type_context_s _cffi_type_context = {
  _cffi_types,
  _cffi_globals,
  _cffi_fields,
  _cffi_struct_unions,
  _cffi_enums,
  _cffi_typenames,
  151,  /* num_globals */
  8,  /* num_struct_unions */
  2,  /* num_enums */
  14,  /* num_typenames */
  NULL,  /* no includes */
  352,  /* num_types */
  1,  /* flags */
};

#ifdef PYPY_VERSION
PyMODINIT_FUNC
_cffi_pypyinit_pythonscriptcffi(const void *p[])
{
    if (((intptr_t)p[0]) >= 0x0A03) {
        _cffi_call_python_org = (void(*)(struct _cffi_externpy_s *, char *))p[1];
    }
    p[0] = (const void *)0x2701;
    p[1] = &_cffi_type_context;
}
#  ifdef _MSC_VER
     PyMODINIT_FUNC
#  if PY_MAJOR_VERSION >= 3
     PyInit_pythonscriptcffi(void) { return NULL; }
#  else
     initpythonscriptcffi(void) { }
#  endif
#  endif
#elif PY_MAJOR_VERSION >= 3
PyMODINIT_FUNC
PyInit_pythonscriptcffi(void)
{
  return _cffi_init("pythonscriptcffi", 0x2701, &_cffi_type_context);
}
#else
PyMODINIT_FUNC
initpythonscriptcffi(void)
{
  _cffi_init("pythonscriptcffi", 0x2701, &_cffi_type_context);
}
#endif
