import argparse
import json


def make_comment_box(msg):
    starsrow = '/**********************************************************/'
    output = [starsrow]
    for l in msg.split('\n'):
        output.append('/*{:^56}*/'.format(l))
    output.append(starsrow)
    return '\n'.join(output)


HEADER = \
"""/**********************************************************/
/*       AUTOGENERATED FILE, DO NOT EDIT BY HAND !        */
/*    Use tools/generate_bindings.py to regenerate it.    */
/**********************************************************/


#include "pythonscript.h"
#include "bindings.h"
#include "core/object.h"

namespace bindings {

"""
FOOTER = \
"""

} // namespace
"""


def generate_forward_declarations(api):
    output = [make_comment_box('Forward declarations'), '']
    for clsapi in api:
        output.append('struct {name};'.format(**clsapi))
    output.append('')
    return '\n'.join(output) + '\n'


def generate_wrapper_classes(api):
    output = [make_comment_box('Wrapper classes'), '']
    for clsapi in api:
        output.append(generate_wrapper_class(clsapi))
    output.append('')
    return '\n'.join(output)


def generate_wrapper_class(clsapi):

    def _comment_entry(item, entry):
        if item[entry]:
            return '    // Bind %s' % entry
        else:
            return '    // No %s to bind' % entry

    output = []
    clsname = clsapi['name']

    # TODO: Handle constructor's parameters ?
    if clsapi['base_class']:
        output.append('struct {name} : public {base_class} {{'.format(**clsapi))
    else:
        output.append('struct {name} {{'.format(**clsapi))
    output.append("""
    ::Object *godot_obj;
    ::Variant godot_variant;

    void set_godot_obj(GodotObject *gobj) {{
        this->godot_obj = gobj->godot_obj;
        this->godot_variant = ::Variant(gobj->godot_obj);
    }}

    explicit {name}(::Object *obj) {{
        this->godot_obj = obj;
        this->godot_variant = ::Variant(obj);
    }}

    {name}() {{
        this->godot_obj = ClassDB::instance("{name}");
        this->godot_variant = ::Variant(this->godot_obj);
    }}
""".format(**clsapi))

    # TODO: do we need this with `def_readonly` ?
    output.append(_comment_entry(clsapi, 'constants'))
    for key, value in clsapi['constants'].items():
        output.append('    const int {key} = {value};'.format(key=key, value=value))
    output.append('\n')
    output.append(_comment_entry(clsapi, 'methods'))
    method_tmpl = \
"""    inline {return_type} {name}({params}) {{
        static MethodBind *mb = ClassDB::get_method("{clsname}", "{name}");
        {return_type} ret;
        mb->ptrcall(this->godot_obj, nullptr, &ret);
        return ret;
    }}
"""
    method_tmpl = \
"""    inline {return_type} {name}({args}) {{
        static MethodBind *mb = ClassDB::get_method("{clsname}", "{name}");
        {ret_def}
        {args_def}
        mb->ptrcall(this->godot_obj, {args_val}, {ret_val});
        {ret}
    }}
"""

    def _build_method_func(clsname, methodapi):
        if methodapi['return_type'] in ('void', ''):
            ret_def, ret_val, ret = '// no return value', 'nullptr', '// no return value'
        else:
            ret_def = '{return_type} ret;'.format(**methodapi)
            ret_val = '&ret'
            ret = 'return ret;'
        if not methodapi['arguments']:
            args = ''
            args_def, args_val = '// no arguments', 'nullptr'
        else:
            args = ', '.join(['{type} {name}'.format(**a) for a in methodapi['arguments']])
            args_def = 'const void *args[%s] = {' % len(methodapi['arguments'])
            args_def += ', '.join(['&%s' % a['name'] for a in methodapi['arguments']])
            args_def += '};'
            args_val = 'args'

        return method_tmpl.format(clsname=clsname,
            args=args, args_def=args_def, args_val=args_val, ret_def=ret_def, ret_val=ret_val, ret=ret, **methodapi)

    for methodapi in clsapi['methods']:
        # No nee to handle default arguments here given they cannot be
        # inferred by pybind11
        output.append(_build_method_func(clsname, methodapi))
        # output.append(method_tmpl.format(clsname=clsname, params=params, **methodapi))

    output.append(_comment_entry(clsapi, 'properties'))
    prop_getter_tmpl = \
"""    inline {type} __prop__{getter}() {{
        static MethodBind *mb = ClassDB::get_method("{clsname}", "{getter}");
        {type} ret;
        mb->ptrcall(this->godot_obj, nullptr, &ret);
        return ret;
    }}
"""
    prop_setter_tmpl = \
"""    inline void __prop__{setter}({type} value) {{
        static MethodBind *mb = ClassDB::get_method("{clsname}", "{setter}");
        const void *args[1] = {{&value}};
        mb->ptrcall(this->godot_obj, args, nullptr);
    }}
"""
    for propapi in clsapi['properties']:
        if propapi['getter']:
            output.append(prop_getter_tmpl.format(clsname=clsname, **propapi))
        if propapi['setter']:
            output.append(prop_setter_tmpl.format(clsname=clsname, **propapi))

    # TODO: bind signals
    output.append("""
};
""")
    return '\n'.join(output)


def generate_bindings_module(api):
    output = [make_comment_box('PyBind11 binding module'), '']
    output.append("""
PYBIND11_PLUGIN(godot_bindings) {
    py::module m("godot.bindings", "Godot classes just for you ;-)");

""")

    for clsapi in api:
        output.append(generate_binding_class(clsapi))
        output.append('')

    output.append("""

    // Expose godot.bindings as a module
    auto sys = py::module::import("sys");
    sys.attr("modules")["godot.bindings"] = m;

    return m.ptr();
}
""")
    return '\n'.join(output)


def generate_binding_class(clsapi):

    def _comment_entry(item, entry):
        if item[entry]:
            return '// Bind %s' % entry
        else:
            return '// No %s to bind' % entry

    def _cook_method_params(methodapi):
        dv_conv = {
            'True': 'true',
            'False': 'false',
            '[]': 'py::make_tuple()'
        }
        params = []
        for a in methodapi['arguments']:
            dv = a['default_value']
            param = 'py::arg("{name}")'.format(**a)
            if dv:
                param += '=' + dv_conv.get(dv, dv)
            params.append(param)
        return ', '.join(params)

    output = []
    clsname = clsapi['name']
    if clsapi['base_class']:
        output.append('py::class_<{name}, {base_class}>(m, "{name}")'.format(**clsapi))
    else:
        output.append('py::class_<{name}>(m, "{name}")'.format(**clsapi))

    # TODO: is there Godot class that take constructor parameters ?
    output.append('.def(py::init<>())')

    if not clsapi['instanciable']:
        # TODO: find a less clunky way to do this...
        output.append('.def("__new__", (py::object cls) -> { py::eval("raise TypeError(\'%s is not instanciable.\')"); })' % clsname)

    output.append(_comment_entry(clsapi, 'methods'))
    for methodapi in clsapi['methods']:
        params = _cook_method_params(methodapi)
        output.append('.def("{name}", &{clsname}::{name}{params})'.format(clsname=clsname, params=params, **methodapi))

    output.append(_comment_entry(clsapi, 'constants'))
    for key, value in clsapi['constants'].items():
        output.append('.def("{key}", {value})'.format(key=key, value=value))

    output.append(_comment_entry(clsapi, 'properties'))
    for prop in clsapi['properties']:
        output.append('.def_property("{name}", &{clsname}::{getter}, &{clsname}::{setter})'.format(clsname=clsname, **prop))

    output.append(';')
    # TODO: bind signals

    return '    ' + '\n        '.join(output)


def main(infd, outfd):
    api = json.load(infd)
    output = HEADER
    output += '\n\n'
    output += generate_forward_declarations(api)
    output += '\n\n'
    output += generate_wrapper_classes(api)
    output += '\n\n'
    output += generate_bindings_module(api)
    output += '\n\n'
    output += FOOTER
    outfd.write(output)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('input', type=argparse.FileType('r'), help='Api json file')
    parser.add_argument('--output', '-o', type=argparse.FileType('w'), default='bindings.gen.cpp',
                        help='Generated output (default: bindings.gen.cpp)')
    args = parser.parse_args()
    main(args.input, args.output)
