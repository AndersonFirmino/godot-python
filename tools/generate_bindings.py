import argparse
import json
import re


def make_comment_box(msg):
    starsrow = '/**********************************************************/'
    output = [starsrow]
    for l in msg.split('\n'):
        output.append('/*{:^56}*/'.format(l))
    output.append(starsrow)
    return '\n'.join(output)


# Fields that should be passed by copy and not by pointer
NO_PTR_TYPES = ('bool', 'int', 'float', 'void')
BASE_TYPES = NO_PTR_TYPES # TODO: remove me
ATOMIC_TYPES = ('String', 'Vector2', 'Rect2', 'Vector3', 'Plane', 'Rect3',
    'Quat', 'Basis', 'Transform2D', 'Transform', 'Color', 'Image', 'NodePath',
    'RefPtr', 'RID', 'InputEvent', 'Dictionary')
# When an argument name is clashing with C++, put it here to get it escaped
RESERVED_NAMES = ('class', 'short', 'long', 'default', 'template', 'char', 'export')


def cooked_varname(varname):
    return varname if varname not in RESERVED_NAMES else varname + '_'


def conv_type(gdtp):
    if gdtp in ATOMIC_TYPES or gdtp == 'Error':
        return '::%s' % gdtp
    return gdtp + ('' if gdtp in NO_PTR_TYPES else '*')


def conv_to_variant(arg):
    if arg['type'] not in NO_PTR_TYPES and arg['type'] not in ATOMIC_TYPES:
        return 'Variant(%s)' % cooked_varname(arg['name'])
    return 'Variant(%s)' % cooked_varname(arg['name'])


def ret_from_variant(rettype, retname):
    if rettype in ('void', ''):
        return 'return;'
    if rettype == 'float':
        return 'return static_cast<real_t>(%s);' % (retname)
    if rettype == 'Error':
        return 'return static_cast<Error>(%s.operator int());' % retname
    if rettype in NO_PTR_TYPES:
        return 'return %s;' % retname
    if rettype in ATOMIC_TYPES:
        return 'return %s.operator ::%s();' % (retname, rettype)
    return 'return new %s(%s);' % (rettype, retname)


HEADER = \
"""/**********************************************************/
/*       AUTOGENERATED FILE, DO NOT EDIT BY HAND !        */
/*    Use tools/generate_bindings.py to regenerate it.    */
/**********************************************************/


#include "pythonscript.h"
#include "bindings.h"
#include "core/object.h"

namespace bindings {

"""
FOOTER = \
"""

} // namespace
"""


def generate_forward_classes_def(api):
    output = []
    for clsapi in api:
        output.append('struct %s;' % clsapi['name'])
    output.append('')
    return '\n'.join(output) + '\n'


def generate_classes_def(api):
    output = [make_comment_box('Classes declarations'), '']
    defs = []
    for clsapi in api:
        defs.append((clsapi['name'], clsapi['base_class'], generate_class_def(clsapi)))

    def _get_children(parent=''):
        return [c for c in defs if c[1] == parent]

    # Reorder the definitions according to inheritance
    parents = _get_children()
    while parents:
        output += [v for _, _, v in parents]
        children = []
        for p in parents:
            children += _get_children(p[0])
        parents = children

    output.append('')
    return '\n'.join(output) + '\n'


def _strip_dummy_function_name(funcname):
    return re.sub(r'[/]', r'_', funcname)


def _mk_meth_name(basename):
    return '__meth__' + _strip_dummy_function_name(basename)


def _mk_getter_name(basename):
    return '__getter__' + _strip_dummy_function_name(basename)


def _mk_setter_name(basename):
    return '__setter__' + _strip_dummy_function_name(basename)


def _mk_function_signature(methodapi, ns=None):
    # Build function signature
    args = ', '.join(['%s %s' % (conv_type(a['type']), cooked_varname(a['name'])) for a in methodapi['arguments']])
    name = _strip_dummy_function_name(methodapi['name'])
    ret = conv_type(methodapi['return_type'])
    return '%s %s%s(%s)' % (ret, ns + '::' if ns else '', _mk_meth_name(name), args)


def _mk_getter_signature(propapi, ns=None):
    tp = conv_type(propapi['type'])
    name = _strip_dummy_function_name(propapi['name'])
    return '%s %s%s()' % (tp, ns+'::' if ns else '', _mk_getter_name(name))


def _mk_setter_signature(propapi, ns=None):
    tp = conv_type(propapi['type'])
    name = _strip_dummy_function_name(propapi['name'])
    return 'void %s%s(%s value)' % (ns+'::' if ns else '', _mk_setter_name(name), tp)


def generate_class_def(clsapi):

    def _comment_entry(item, entry):
        if item[entry]:
            return '    // Bind %s' % entry
        else:
            return '    // No %s to bind' % entry

    output = []

    # TODO: Handle constructor's parameters ?
    if clsapi['base_class']:
        output.append('struct {name} : public {base_class} {{'.format(**clsapi))
    else:
        output.append('struct {name} {{'.format(**clsapi))
    output.append("""
    ::Object *godot_obj;
    ::Variant godot_variant;

    void set_godot_obj(GodotObject *gobj) {{
        this->godot_obj = gobj->godot_obj;
        this->godot_variant = ::Variant(gobj->godot_obj);
    }}

    explicit {name}(::Object *obj) {{
        this->godot_obj = obj;
        this->godot_variant = ::Variant(obj);
    }}

    {name}() {{
        this->godot_obj = ClassDB::instance("{name}");
        this->godot_variant = ::Variant(this->godot_obj);
    }}
""".format(**clsapi))
    output.append('    // Bind methods')
    for methapi in clsapi['methods']:
        output.append('    ' + _mk_function_signature(methapi) + ';')

    output.append('    // Bind properties')
    for propapi in clsapi['properties']:
        if propapi['getter']:
            output.append('    ' + _mk_getter_signature(propapi) + ';')
        if propapi['setter']:
            output.append('    ' + _mk_setter_signature(propapi) + ';')

    # No need to add constants to the wrapper class

    # TODO: bind signals
    output.append('\n};\n')
    return '\n'.join(output)


def generate_classes_impl(api):
    output = [make_comment_box('Classes implementation'), '']
    for clsapi in api:
        output.append(generate_class_impl(clsapi))
    output.append('')
    return '\n'.join(output)


def generate_class_impl(clsapi):
    output = []
    clsname = clsapi['name']

    output.append(make_comment_box(clsname))
    output.append('')

    def _build_method_impl(clsname, methodapi):
        output = [_mk_function_signature(methapi, ns=clsname) + ' {']
        args_count = len(methodapi['arguments'])
        # Generic body
        output.append('static MethodBind *__mb = ClassDB::get_method("%s", "%s");' % (clsname, methodapi['name']))
        output.append('Variant::CallError __err;')
        # Function params conversion
        if args_count:
            output.append('const Variant *__args[%s];' % args_count)
            for i, arg in enumerate(methodapi['arguments']):
                output.append('__args[%s] = new %s;' % (i, conv_to_variant(arg)))
        # Actual call
        output.append('Variant ret = __mb->call(this->godot_obj, %s, %s, __err);' % ('__args' if args_count else 'nullptr', args_count))
        # params cleaning
        if args_count:
            output.append('for (int i = 0; i < %s; ++i) {' % args_count)
            output.append('    delete __args[i];')
            output.append('}')
        # Return value
        output.append(ret_from_variant(methodapi['return_type'], 'ret'))
        # TODO: error handling
        return '\n    '.join(output) + '\n}\n'

    for methapi in clsapi['methods']:
        output.append(_build_method_impl(clsname, methapi))
        output.append('')

    def _build_getter_impl(clsname, propapi):
        if not propapi['getter']:
            return ''
        output = [_mk_getter_signature(propapi, ns=clsname) + ' {']
        output.append('static MethodBind *__mb = ClassDB::get_method("%s", "%s");' % (clsname, propapi['getter']))
        output.append('Variant::CallError __err;')
        output.append('Variant __ret = __mb->call(this->godot_obj, nullptr, 0, __err);')
        # TODO: error handling
        # Return value
        output.append(ret_from_variant(propapi['type'], '__ret'))
        return '\n    '.join(output) + '\n}\n'

    def _build_setter_impl(clsname, propapi):
        if not propapi['setter']:
            return ''
        output = [_mk_setter_signature(propapi, ns=clsname) + ' {']
        output.append('static MethodBind *__mb = ClassDB::get_method("%s", "%s");' % (clsname, propapi['setter']))
        output.append('Variant::CallError __err;')
        output.append('const Variant *__args[1];')
        output.append('__args[0] = new %s;' % conv_to_variant({'type': propapi['type'], 'name': 'value'}))
        output.append('__mb->call(this->godot_obj, __args, 1, __err);')
        # TODO: error handling
        return '\n    '.join(output) + '\n}\n'

    for propapi in clsapi['properties']:
        if propapi['getter']:
            output.append(_build_getter_impl(clsname, propapi))
        if propapi['setter']:
            output.append(_build_setter_impl(clsname, propapi))


    # for propapi in clsapi['properties']:
    #     if propapi['getter']:
    #         output.append('    ' + _mk_getter_signature(propapi) + ';')
    #     if propapi['setter']:
    #         output.append('    ' + _mk_setter_signature(propapi) + ';')


#     def _build_method_func_ptrcall(clsname, methodapi):
#         method_tmpl = \
# """    inline {return_type} {name}({args}) {{
#         static MethodBind *mb = ClassDB::get_method("{clsname}", "{name}");
#         {ret_def}
#         {args_def}
#         mb->ptrcall(this->godot_obj, {args_val}, {ret_val});
#         {ret}
#     }}
# """
#         if methodapi['return_type'] in ('void', ''):
#             ret_def, ret_val, ret = '// no return value', 'nullptr', '// no return value'
#         else:
#             ret_def = '{return_type} ret;'.format(**methodapi)
#             ret_val = '&ret'
#             ret = 'return ret;'
#         if not methodapi['arguments']:
#             args = ''
#             args_def, args_val = '// no arguments', 'nullptr'
#         else:
#             args = ', '.join(['{type} {ptr}{name}'.format(**a, ptr='' if a['type'] in BASE_TYPES else '*')
#                               for a in methodapi['arguments']])
#             args_def = 'const void *args[%s] = {' % len(methodapi['arguments'])
#             args_def += ', '.join([('&' if a['type'] in BASE_TYPES else '') + a['name'] for a in methodapi['arguments']])
#             args_def += '};'
#             args_val = 'args'

#         return method_tmpl.format(clsname=clsname,
#             args=args, args_def=args_def, args_val=args_val, ret_def=ret_def, ret_val=ret_val, ret=ret, **methodapi)

#     for methodapi in clsapi['methods']:
#         # No nee to handle default arguments here given they cannot be
#         # inferred by pybind11
#         output.append(_build_method_func(clsname, methodapi))
#         # output.append(method_tmpl.format(clsname=clsname, params=params, **methodapi))

#     # TODO: bind signals
#     output.append("""
# };
# """)
    return '\n'.join(output)


def generate_bindings_module(api):
    output = [make_comment_box('PyBind11 binding module'), '']
    output.append("""
PYBIND11_PLUGIN(godot_bindings) {
    py::module m("godot.bindings", "Godot classes just for you ;-)");

""")

    for clsapi in api:
        output.append(generate_binding_class(clsapi))
        output.append('')

    output.append("""

    // Expose godot.bindings as a module
    auto sys = py::module::import("sys");
    sys.attr("modules")["godot.bindings"] = m;

    return m.ptr();
}
""")
    return '\n'.join(output)


def generate_binding_class(clsapi):

    def _comment_entry(item, entry):
        if item[entry]:
            return '// Bind %s' % entry
        else:
            return '// No %s to bind' % entry

    def _cook_method_params(methodapi):
        dv_conv = {
            'True': 'true',
            'False': 'false',
            '[]': 'py::make_tuple()'
        }
        params = []
        for a in methodapi['arguments']:
            dv = a['default_value']
            param = 'py::arg("{name}")'.format(**a)
            if dv:
                param += '=' + dv_conv.get(dv, dv)
            params.append(param)
        return ', '.join(params)

    output = []
    clsname = clsapi['name']
    if clsapi['base_class']:
        output.append('py::class_<{name}, {base_class}>(m, "{name}")'.format(**clsapi))
    else:
        output.append('py::class_<{name}>(m, "{name}")'.format(**clsapi))

    # TODO: is there Godot class that take constructor parameters ?
    output.append('.def(py::init<>())')

    if not clsapi['instanciable']:
        # TODO: find a less clunky way to do this...
        output.append('.def("__new__", [](py::object cls) { py::eval("raise TypeError(\'%s is not instanciable.\')"); })' % clsname)

    output.append(_comment_entry(clsapi, 'methods'))
    for methodapi in clsapi['methods']:
        params = _cook_method_params(methodapi)
        output.append('.def("{name}", &{clsname}::{methname}{c}{params})'.format(
            clsname=clsname, methname=_mk_meth_name(methodapi['name']),
            c=', ' if params else '', params=params, **methodapi))

    output.append(_comment_entry(clsapi, 'constants'))
    for key, value in clsapi['constants'].items():
        output.append('.def("{key}", {value})'.format(key=key, value=value))

    output.append(_comment_entry(clsapi, 'properties'))
    for prop in clsapi['properties']:
        output.append(
            '.def_property("{name}", &{clsname}::{gettername}, &{clsname}::{settername})'.format(
                clsname=clsname, gettername=_mk_getter_name(prop['name']),
                settername=_mk_setter_name(prop['name']), **prop))

    output.append(';')
    # TODO: bind signals

    return '    ' + '\n        '.join(output)


def main(infd, outfd):
    api = json.load(infd)
    output = HEADER
    output += '\n\n'
    output += generate_forward_classes_def(api)
    output += '\n\n'
    output += generate_classes_def(api)
    output += '\n\n'
    output += generate_classes_impl(api)
    output += '\n\n'
    output += generate_bindings_module(api)
    output += '\n\n'
    output += FOOTER
    outfd.write(output)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('input', type=argparse.FileType('r'), help='Api json file')
    parser.add_argument('--output', '-o', type=argparse.FileType('w'), default='bindings.gen.cpp',
                        help='Generated output (default: bindings.gen.cpp)')
    args = parser.parse_args()
    main(args.input, args.output)
